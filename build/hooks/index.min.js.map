{"version":3,"file":"./build/hooks/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","../../packages/hooks/src/validateNamespace.js","../../packages/hooks/src/validateHookName.js","../../packages/hooks/src/createAddHook.js","../../packages/hooks/src/createRemoveHook.js","../../packages/hooks/src/createHasHook.js","../../packages/hooks/src/createRunHook.js","../../packages/hooks/src/createCurrentHook.js","../../packages/hooks/src/createDoingHook.js","../../packages/hooks/src/createDidHook.js","../../packages/hooks/src/createHooks.js","../../packages/hooks/src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * Validate a namespace string.\r\n *\r\n * @param {string} namespace The namespace to validate - should take the form\r\n *                           `vendor/plugin/function`.\r\n *\r\n * @return {boolean} Whether the namespace is valid.\r\n */\r\nfunction validateNamespace( namespace ) {\r\n\tif ( 'string' !== typeof namespace || '' === namespace ) {\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error( 'The namespace must be a non-empty string.' );\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.\\-\\/]*$/.test( namespace ) ) {\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error(\r\n\t\t\t'The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.'\r\n\t\t);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nexport default validateNamespace;\r\n","/**\r\n * Validate a hookName string.\r\n *\r\n * @param {string} hookName The hook name to validate. Should be a non empty string containing\r\n *                          only numbers, letters, dashes, periods and underscores. Also,\r\n *                          the hook name cannot begin with `__`.\r\n *\r\n * @return {boolean} Whether the hook name is valid.\r\n */\r\nfunction validateHookName( hookName ) {\r\n\tif ( 'string' !== typeof hookName || '' === hookName ) {\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error( 'The hook name must be a non-empty string.' );\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( /^__/.test( hookName ) ) {\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error( 'The hook name cannot begin with `__`.' );\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.-]*$/.test( hookName ) ) {\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error(\r\n\t\t\t'The hook name can only contain numbers, letters, dashes, periods and underscores.'\r\n\t\t);\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nexport default validateHookName;\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport validateNamespace from './validateNamespace.js';\r\nimport validateHookName from './validateHookName.js';\r\n\r\n/**\r\n * @callback AddHook\r\n *\r\n * Adds the hook to the appropriate hooks container.\r\n *\r\n * @param {string}               hookName      Name of hook to add\r\n * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.\r\n * @param {import('.').Callback} callback      Function to call when the hook is run\r\n * @param {number}               [priority=10] Priority of this hook\r\n */\r\n\r\n/**\r\n * Returns a function which, when invoked, will add a hook.\r\n *\r\n * @param {import('.').Hooks}    hooks    Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n *\r\n * @return {AddHook} Function that adds a new hook.\r\n */\r\nfunction createAddHook( hooks, storeKey ) {\r\n\treturn function addHook( hookName, namespace, callback, priority = 10 ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\tif ( ! validateHookName( hookName ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( ! validateNamespace( namespace ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( 'function' !== typeof callback ) {\r\n\t\t\t// eslint-disable-next-line no-console\r\n\t\t\tconsole.error( 'The hook callback must be a function.' );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Validate numeric priority\r\n\t\tif ( 'number' !== typeof priority ) {\r\n\t\t\t// eslint-disable-next-line no-console\r\n\t\t\tconsole.error(\r\n\t\t\t\t'If specified, the hook priority must be a number.'\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst handler = { callback, priority, namespace };\r\n\r\n\t\tif ( hooksStore[ hookName ] ) {\r\n\t\t\t// Find the correct insert index of the new hook.\r\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\r\n\r\n\t\t\t/** @type {number} */\r\n\t\t\tlet i;\r\n\t\t\tfor ( i = handlers.length; i > 0; i-- ) {\r\n\t\t\t\tif ( priority >= handlers[ i - 1 ].priority ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( i === handlers.length ) {\r\n\t\t\t\t// If append, operate via direct assignment.\r\n\t\t\t\thandlers[ i ] = handler;\r\n\t\t\t} else {\r\n\t\t\t\t// Otherwise, insert before index via splice.\r\n\t\t\t\thandlers.splice( i, 0, handler );\r\n\t\t\t}\r\n\r\n\t\t\t// We may also be currently executing this hook.  If the callback\r\n\t\t\t// we're adding would come after the current callback, there's no\r\n\t\t\t// problem; otherwise we need to increase the execution index of\r\n\t\t\t// any other runs by 1 to account for the added element.\r\n\t\t\thooksStore.__current.forEach( ( hookInfo ) => {\r\n\t\t\t\tif (\r\n\t\t\t\t\thookInfo.name === hookName &&\r\n\t\t\t\t\thookInfo.currentIndex >= i\r\n\t\t\t\t) {\r\n\t\t\t\t\thookInfo.currentIndex++;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\t} else {\r\n\t\t\t// This is the first hook of its type.\r\n\t\t\thooksStore[ hookName ] = {\r\n\t\t\t\thandlers: [ handler ],\r\n\t\t\t\truns: 0,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif ( hookName !== 'hookAdded' ) {\r\n\t\t\thooks.doAction(\r\n\t\t\t\t'hookAdded',\r\n\t\t\t\thookName,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tcallback,\r\n\t\t\t\tpriority\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n}\r\n\r\nexport default createAddHook;\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport validateNamespace from './validateNamespace.js';\r\nimport validateHookName from './validateHookName.js';\r\n\r\n/**\r\n * @callback RemoveHook\r\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\r\n * and namespace.\r\n *\r\n * @param {string} hookName  The name of the hook to modify.\r\n * @param {string} namespace The unique namespace identifying the callback in the\r\n *                           form `vendor/plugin/function`.\r\n *\r\n * @return {number | undefined} The number of callbacks removed.\r\n */\r\n\r\n/**\r\n * Returns a function which, when invoked, will remove a specified hook or all\r\n * hooks by the given name.\r\n *\r\n * @param {import('.').Hooks}    hooks             Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,\r\n *                                                 without regard to namespace. Used to create\r\n *                                                 `removeAll*` functions.\r\n *\r\n * @return {RemoveHook} Function that removes hooks.\r\n */\r\nfunction createRemoveHook( hooks, storeKey, removeAll = false ) {\r\n\treturn function removeHook( hookName, namespace ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\tif ( ! validateHookName( hookName ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( ! removeAll && ! validateNamespace( namespace ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Bail if no hooks exist by this name.\r\n\t\tif ( ! hooksStore[ hookName ] ) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tlet handlersRemoved = 0;\r\n\r\n\t\tif ( removeAll ) {\r\n\t\t\thandlersRemoved = hooksStore[ hookName ].handlers.length;\r\n\t\t\thooksStore[ hookName ] = {\r\n\t\t\t\truns: hooksStore[ hookName ].runs,\r\n\t\t\t\thandlers: [],\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\t// Try to find the specified callback to remove.\r\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\r\n\t\t\tfor ( let i = handlers.length - 1; i >= 0; i-- ) {\r\n\t\t\t\tif ( handlers[ i ].namespace === namespace ) {\r\n\t\t\t\t\thandlers.splice( i, 1 );\r\n\t\t\t\t\thandlersRemoved++;\r\n\t\t\t\t\t// This callback may also be part of a hook that is\r\n\t\t\t\t\t// currently executing.  If the callback we're removing\r\n\t\t\t\t\t// comes after the current callback, there's no problem;\r\n\t\t\t\t\t// otherwise we need to decrease the execution index of any\r\n\t\t\t\t\t// other runs by 1 to account for the removed element.\r\n\t\t\t\t\thooksStore.__current.forEach( ( hookInfo ) => {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\thookInfo.name === hookName &&\r\n\t\t\t\t\t\t\thookInfo.currentIndex >= i\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\thookInfo.currentIndex--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( hookName !== 'hookRemoved' ) {\r\n\t\t\thooks.doAction( 'hookRemoved', hookName, namespace );\r\n\t\t}\r\n\r\n\t\treturn handlersRemoved;\r\n\t};\r\n}\r\n\r\nexport default createRemoveHook;\r\n","/**\r\n * @callback HasHook\r\n *\r\n * Returns whether any handlers are attached for the given hookName and optional namespace.\r\n *\r\n * @param {string} hookName    The name of the hook to check for.\r\n * @param {string} [namespace] Optional. The unique namespace identifying the callback\r\n *                             in the form `vendor/plugin/function`.\r\n *\r\n * @return {boolean} Whether there are handlers that are attached to the given hook.\r\n */\r\n/**\r\n * Returns a function which, when invoked, will return whether any handlers are\r\n * attached to a particular hook.\r\n *\r\n * @param {import('.').Hooks}    hooks    Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n *\r\n * @return {HasHook} Function that returns whether any handlers are\r\n *                   attached to a particular hook and optional namespace.\r\n */\r\nfunction createHasHook( hooks, storeKey ) {\r\n\treturn function hasHook( hookName, namespace ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\t// Use the namespace if provided.\r\n\t\tif ( 'undefined' !== typeof namespace ) {\r\n\t\t\treturn (\r\n\t\t\t\thookName in hooksStore &&\r\n\t\t\t\thooksStore[ hookName ].handlers.some(\r\n\t\t\t\t\t( hook ) => hook.namespace === namespace\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn hookName in hooksStore;\r\n\t};\r\n}\r\n\r\nexport default createHasHook;\r\n","/**\r\n * Returns a function which, when invoked, will execute all callbacks\r\n * registered to a hook of the specified type, optionally returning the final\r\n * value of the call chain.\r\n *\r\n * @param {import('.').Hooks}    hooks                  Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n * @param {boolean}              [returnFirstArg=false] Whether each hook callback is expected to\r\n *                                                      return its first argument.\r\n *\r\n * @return {(hookName:string, ...args: unknown[]) => undefined|unknown} Function that runs hook callbacks.\r\n */\r\nfunction createRunHook( hooks, storeKey, returnFirstArg = false ) {\r\n\treturn function runHooks( hookName, ...args ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\tif ( ! hooksStore[ hookName ] ) {\r\n\t\t\thooksStore[ hookName ] = {\r\n\t\t\t\thandlers: [],\r\n\t\t\t\truns: 0,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\thooksStore[ hookName ].runs++;\r\n\r\n\t\tconst handlers = hooksStore[ hookName ].handlers;\r\n\r\n\t\t// The following code is stripped from production builds.\r\n\t\tif ( 'production' !== process.env.NODE_ENV ) {\r\n\t\t\t// Handle any 'all' hooks registered.\r\n\t\t\tif ( 'hookAdded' !== hookName && hooksStore.all ) {\r\n\t\t\t\thandlers.push( ...hooksStore.all.handlers );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( ! handlers || ! handlers.length ) {\r\n\t\t\treturn returnFirstArg ? args[ 0 ] : undefined;\r\n\t\t}\r\n\r\n\t\tconst hookInfo = {\r\n\t\t\tname: hookName,\r\n\t\t\tcurrentIndex: 0,\r\n\t\t};\r\n\r\n\t\thooksStore.__current.push( hookInfo );\r\n\r\n\t\twhile ( hookInfo.currentIndex < handlers.length ) {\r\n\t\t\tconst handler = handlers[ hookInfo.currentIndex ];\r\n\r\n\t\t\tconst result = handler.callback.apply( null, args );\r\n\t\t\tif ( returnFirstArg ) {\r\n\t\t\t\targs[ 0 ] = result;\r\n\t\t\t}\r\n\r\n\t\t\thookInfo.currentIndex++;\r\n\t\t}\r\n\r\n\t\thooksStore.__current.pop();\r\n\r\n\t\tif ( returnFirstArg ) {\r\n\t\t\treturn args[ 0 ];\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t};\r\n}\r\n\r\nexport default createRunHook;\r\n","/**\r\n * Returns a function which, when invoked, will return the name of the\r\n * currently running hook, or `null` if no hook of the given type is currently\r\n * running.\r\n *\r\n * @param {import('.').Hooks}    hooks    Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n *\r\n * @return {() => string | null} Function that returns the current hook name or null.\r\n */\r\nfunction createCurrentHook( hooks, storeKey ) {\r\n\treturn function currentHook() {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\treturn (\r\n\t\t\thooksStore.__current[ hooksStore.__current.length - 1 ]?.name ??\r\n\t\t\tnull\r\n\t\t);\r\n\t};\r\n}\r\n\r\nexport default createCurrentHook;\r\n","/**\r\n * @callback DoingHook\r\n * Returns whether a hook is currently being executed.\r\n *\r\n * @param {string} [hookName] The name of the hook to check for.  If\r\n *                            omitted, will check for any hook being executed.\r\n *\r\n * @return {boolean} Whether the hook is being executed.\r\n */\r\n\r\n/**\r\n * Returns a function which, when invoked, will return whether a hook is\r\n * currently being executed.\r\n *\r\n * @param {import('.').Hooks}    hooks    Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n *\r\n * @return {DoingHook} Function that returns whether a hook is currently\r\n *                     being executed.\r\n */\r\nfunction createDoingHook( hooks, storeKey ) {\r\n\treturn function doingHook( hookName ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\t// If the hookName was not passed, check for any current hook.\r\n\t\tif ( 'undefined' === typeof hookName ) {\r\n\t\t\treturn 'undefined' !== typeof hooksStore.__current[ 0 ];\r\n\t\t}\r\n\r\n\t\t// Return the __current hook.\r\n\t\treturn hooksStore.__current[ 0 ]\r\n\t\t\t? hookName === hooksStore.__current[ 0 ].name\r\n\t\t\t: false;\r\n\t};\r\n}\r\n\r\nexport default createDoingHook;\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport validateHookName from './validateHookName.js';\r\n\r\n/**\r\n * @callback DidHook\r\n *\r\n * Returns the number of times an action has been fired.\r\n *\r\n * @param {string} hookName The hook name to check.\r\n *\r\n * @return {number | undefined} The number of times the hook has run.\r\n */\r\n\r\n/**\r\n * Returns a function which, when invoked, will return the number of times a\r\n * hook has been called.\r\n *\r\n * @param {import('.').Hooks}    hooks    Hooks instance.\r\n * @param {import('.').StoreKey} storeKey\r\n *\r\n * @return {DidHook} Function that returns a hook's call count.\r\n */\r\nfunction createDidHook( hooks, storeKey ) {\r\n\treturn function didHook( hookName ) {\r\n\t\tconst hooksStore = hooks[ storeKey ];\r\n\r\n\t\tif ( ! validateHookName( hookName ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\treturn hooksStore[ hookName ] && hooksStore[ hookName ].runs\r\n\t\t\t? hooksStore[ hookName ].runs\r\n\t\t\t: 0;\r\n\t};\r\n}\r\n\r\nexport default createDidHook;\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport createAddHook from './createAddHook';\r\nimport createRemoveHook from './createRemoveHook';\r\nimport createHasHook from './createHasHook';\r\nimport createRunHook from './createRunHook';\r\nimport createCurrentHook from './createCurrentHook';\r\nimport createDoingHook from './createDoingHook';\r\nimport createDidHook from './createDidHook';\r\n\r\n/**\r\n * Internal class for constructing hooks. Use `createHooks()` function\r\n *\r\n * Note, it is necessary to expose this class to make its type public.\r\n *\r\n * @private\r\n */\r\nexport class _Hooks {\r\n\tconstructor() {\r\n\t\t/** @type {import('.').Store} actions */\r\n\t\tthis.actions = Object.create( null );\r\n\t\tthis.actions.__current = [];\r\n\r\n\t\t/** @type {import('.').Store} filters */\r\n\t\tthis.filters = Object.create( null );\r\n\t\tthis.filters.__current = [];\r\n\r\n\t\tthis.addAction = createAddHook( this, 'actions' );\r\n\t\tthis.addFilter = createAddHook( this, 'filters' );\r\n\t\tthis.removeAction = createRemoveHook( this, 'actions' );\r\n\t\tthis.removeFilter = createRemoveHook( this, 'filters' );\r\n\t\tthis.hasAction = createHasHook( this, 'actions' );\r\n\t\tthis.hasFilter = createHasHook( this, 'filters' );\r\n\t\tthis.removeAllActions = createRemoveHook( this, 'actions', true );\r\n\t\tthis.removeAllFilters = createRemoveHook( this, 'filters', true );\r\n\t\tthis.doAction = createRunHook( this, 'actions' );\r\n\t\tthis.applyFilters = createRunHook( this, 'filters', true );\r\n\t\tthis.currentAction = createCurrentHook( this, 'actions' );\r\n\t\tthis.currentFilter = createCurrentHook( this, 'filters' );\r\n\t\tthis.doingAction = createDoingHook( this, 'actions' );\r\n\t\tthis.doingFilter = createDoingHook( this, 'filters' );\r\n\t\tthis.didAction = createDidHook( this, 'actions' );\r\n\t\tthis.didFilter = createDidHook( this, 'filters' );\r\n\t}\r\n}\r\n\r\n/** @typedef {_Hooks} Hooks */\r\n\r\n/**\r\n * Returns an instance of the hooks object.\r\n *\r\n * @return {Hooks} A Hooks instance.\r\n */\r\nfunction createHooks() {\r\n\treturn new _Hooks();\r\n}\r\n\r\nexport default createHooks;\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport createHooks from './createHooks';\r\n\r\n/** @typedef {(...args: any[])=>any} Callback */\r\n\r\n/**\r\n * @typedef Handler\r\n * @property {Callback} callback  The callback\r\n * @property {string}   namespace The namespace\r\n * @property {number}   priority  The namespace\r\n */\r\n\r\n/**\r\n * @typedef Hook\r\n * @property {Handler[]} handlers Array of handlers\r\n * @property {number}    runs     Run counter\r\n */\r\n\r\n/**\r\n * @typedef Current\r\n * @property {string} name         Hook name\r\n * @property {number} currentIndex The index\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, Hook> & {__current: Current[]}} Store\r\n */\r\n\r\n/**\r\n * @typedef {'actions' | 'filters'} StoreKey\r\n */\r\n\r\n/**\r\n * @typedef {import('./createHooks').Hooks} Hooks\r\n */\r\n\r\nexport const defaultHooks = createHooks();\r\n\r\nconst {\r\n\taddAction,\r\n\taddFilter,\r\n\tremoveAction,\r\n\tremoveFilter,\r\n\thasAction,\r\n\thasFilter,\r\n\tremoveAllActions,\r\n\tremoveAllFilters,\r\n\tdoAction,\r\n\tapplyFilters,\r\n\tcurrentAction,\r\n\tcurrentFilter,\r\n\tdoingAction,\r\n\tdoingFilter,\r\n\tdidAction,\r\n\tdidFilter,\r\n\tactions,\r\n\tfilters,\r\n} = defaultHooks;\r\n\r\nexport {\r\n\tcreateHooks,\r\n\taddAction,\r\n\taddFilter,\r\n\tremoveAction,\r\n\tremoveFilter,\r\n\thasAction,\r\n\thasFilter,\r\n\tremoveAllActions,\r\n\tremoveAllFilters,\r\n\tdoAction,\r\n\tapplyFilters,\r\n\tcurrentAction,\r\n\tcurrentFilter,\r\n\tdoingAction,\r\n\tdoingFilter,\r\n\tdidAction,\r\n\tdidFilter,\r\n\tactions,\r\n\tfilters,\r\n};\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","namespace","console","error","test","hookName","hooks","storeKey","callback","priority","hooksStore","validateHookName","validateNamespace","handler","handlers","i","length","splice","__current","forEach","hookInfo","name","currentIndex","runs","doAction","removeAll","handlersRemoved","some","hook","returnFirstArg","args","undefined","push","result","apply","pop","_hooksStore$__current","_Hooks","constructor","this","actions","create","filters","addAction","createAddHook","addFilter","removeAction","createRemoveHook","removeFilter","hasAction","createHasHook","hasFilter","removeAllActions","removeAllFilters","createRunHook","applyFilters","currentAction","createCurrentHook","currentFilter","doingAction","createDoingHook","doingFilter","didAction","createDidHook","didFilter","defaultHooks","createHooks"],"sourceRoot":""}