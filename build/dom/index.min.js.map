{"version":3,"file":"./build/dom/index.min.js","mappings":"mBACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLdF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDR,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFf,EAAyBM,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,+uBCiD9D,SAASC,EAAWC,GACnB,OACCA,EAAQC,YAAc,GACtBD,EAAQE,aAAe,GACvBF,EAAQG,iBAAiBC,OAAS,CAEpC,CAuCO,SAASC,EAAMC,GAAS,WAAEC,GAAa,GAAU,CAAC,GAExD,MAAMC,EAAWF,EAAQG,iBAvE1B,SAAwBF,GACvB,MAAO,CACNA,EAAa,kCAAoC,aACjD,UACA,yBACA,6CACA,yBACA,2BACA,8BACA,SACA,QACA,aACA,kDACCG,KAAM,IACT,CAyD4CC,CAAeJ,IAE1D,OAAOK,MAAMC,KAAML,GAAWM,QAAUd,IACvC,IAAOD,EAAWC,GACjB,OAAO,EAGR,MAAM,SAAEe,GAAaf,EACrB,MAAK,SAAWe,GAtClB,SAA+Bf,GAE9B,MAAMgB,EAAMhB,EAAQiB,QAAS,aAC7B,IAAOD,EACN,OAAO,EAIR,MAAME,EAAMlB,EAAQmB,cAAcC,cACjC,gBAAkBJ,EAAIK,KAAO,MAE9B,QAAUH,GAAOnB,EAAWmB,EAC7B,CA2BUI,CAC2BtB,EAIxB,GAEb,CCpGA,SAASuB,EAAavB,GACrB,MAAMwB,EAAWxB,EAAQyB,aAAc,YACvC,OAAoB,OAAbD,EAAoB,EAAIE,SAAUF,EAAU,GACpD,CASO,SAASG,EAAiB3B,GAChC,OAAmC,IAA5BuB,EAAavB,EACrB,CA4DA,SAAS4B,EAA4B5B,EAAS6B,GAC7C,MAAO,CAAE7B,UAAS6B,QACnB,CAUA,SAASC,EAA4BC,GACpC,OAAOA,EAAO/B,OACf,CAYA,SAASgC,EAAwBlD,EAAGmD,GACnC,MAAMC,EAAYX,EAAazC,EAAEkB,SAC3BmC,EAAYZ,EAAaU,EAAEjC,SAEjC,OAAKkC,IAAcC,EACXrD,EAAE+C,MAAQI,EAAEJ,MAGbK,EAAYC,CACpB,CASA,SAASC,EAAgBC,GACxB,OAAOA,EACLvB,OAAQa,GACRX,IAAKY,GACLU,KAAMN,GACNhB,IAAKc,GACLS,OAlGH,WAEC,MAAMC,EAAuB,CAAC,EAE9B,OAAO,SACiCC,EACFzC,GAErC,MAAM,SAAEe,EAAQ,KAAE2B,EAAI,QAAEC,EAAO,KAAEtB,GAASrB,EAG1C,GAAkB,UAAbe,GAAiC,UAAT2B,IAAsBrB,EAClD,OAAOoB,EAAOG,OAAQ5C,GAGvB,MAAM6C,EAAYL,EAAqB9C,eAAgB2B,GAIvD,IADiBsB,GAAaE,EAE7B,OAAOJ,EAMR,GAAKI,EAAY,CAChB,MAAMC,EAAmBN,EAAsBnB,GAC/CoB,EAASA,EAAO3B,QAAUiC,GAAOA,IAAMD,GACxC,CAIA,OAFAN,EAAsBnB,GAASrB,EAExByC,EAAOG,OAAQ5C,EACvB,CACD,CA+DWgD,GAAoC,GAC/C,CAMO,SAAS3C,EAAMC,GACrB,OAAO8B,EAAgBa,EAAe3C,GACvC,CAUO,SAAS4C,EAAclD,GAC7B,OAAOoC,EAAgBa,EAAejD,EAAQmB,cAAcgC,OAC1DC,UACA/C,MACEgD,GAEDrD,EAAQsD,wBAAyBD,GACjCrD,EAAQuD,6BAEZ,CAUO,SAASC,EAAUxD,GACzB,OAAOoC,EAAgBa,EAAejD,EAAQmB,cAAcgC,OAAS9C,MAClEgD,GAEDrD,EAAQsD,wBAAyBD,GACjCrD,EAAQyD,6BAEX,CC7Ke,SAASC,EAAuBC,GAI9C,IAAOA,EAAMC,UAAY,CACxB,MAAMC,EAAQjD,MAAMC,KAAM8C,EAAMxD,kBAGhC,GAAsB,IAAjB0D,EAAMzD,OACV,OAAOyD,EAAO,GAIf,MAAMC,EAAgBD,EAAM/C,QAAQ,EAAIiD,WAAaA,EAAQ,IAG7D,GAA8B,IAAzBD,EAAc1D,OAClB,OAAOuD,EAAMK,wBAGd,GAA8B,IAAzBF,EAAc1D,OAClB,OAAO0D,EAAe,GAGvB,IACCG,IAAKC,EACLC,OAAQC,EACRC,KAAMC,EACNC,MAAOC,GACJV,EAAe,GAEnB,IAAM,MAAM,IAAEG,EAAG,OAAEE,EAAM,KAAEE,EAAI,MAAEE,KAAWT,EACtCG,EAAMC,IAAcA,EAAcD,GAClCE,EAASC,IAAiBA,EAAiBD,GAC3CE,EAAOC,IAAeA,EAAeD,GACrCE,EAAQC,IAAgBA,EAAgBD,GAG9C,OAAO,IAAIE,OAAOC,QACjBJ,EACAJ,EACAM,EAAgBF,EAChBF,EAAiBF,EAEnB,CAEA,MAAM,eAAES,GAAmBhB,GACrB,cAAExC,GAAkBwD,EAG1B,GAAiC,OAA5BA,EAAe5D,SAAoB,CACvC,MAAM,WAAE6D,GAAeD,EAEjB9C,EACLjB,MAAMC,KAAM+D,EAAWC,YACtBC,QAASH,IAGXhB,EAAQxC,EAAc4D,eAChBC,SAAUJ,EAAY/C,GAC5B8B,EAAMsB,OAAQL,EAAY/C,EAC3B,CAEA,MAAMgC,EAAQF,EAAMxD,iBAIpB,GAAK0D,EAAMzD,OAAS,EACnB,OAAO,KAGR,IAAI8E,EAAOrB,EAAO,GAOlB,IAAOqB,GAAwB,IAAhBA,EAAKC,OAAe,CAElC,MAAMC,EAAUjE,EAAckE,eAAgB,MAE9C1B,EAAQA,EAAM2B,cACRC,WAAYH,GAClBF,EAAOvB,EAAMxD,iBAAkB,GACdiF,EAAQR,WACzBQ,EAAQR,WAAWY,YAAaJ,EACjC,CAEA,OAAOF,CACR,CC1Fe,SAASO,EAAkBC,GACzC,MAAMC,EAAYD,EAAIE,eAEhBjC,EAAQgC,EAAUE,WAAaF,EAAUG,WAAY,GAAM,KAEjE,OAAOnC,EAIAD,EAAuBC,GAHtB,IAIT,CCPe,SAASoC,EAA0BC,GAChCA,EAAIC,YACrB,MAAMN,EAAYK,EAAIC,YAAYL,eAE5BjC,EAAQgC,EAAUE,WAAaF,EAAUG,WAAY,GAAM,KACjE,QAAUnC,IAAWA,EAAMC,SAC5B,CCjBe,SAASsC,EAAoBC,GAE3C,MAA0B,UAAnBA,GAAMpF,QACd,CCOe,SAASqF,EAAaD,GAgBpC,OACGD,EAAoBC,IACrBA,EAAKzD,OAhBe,CACrB,SACA,WACA,SACA,OACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QAKiB2D,SAAUF,EAAKzD,OACd,aAAlByD,EAAKpF,UACmD,SAA3BoF,EAAOG,eAEtC,CCvBe,SAASC,EAAiCP,GACxD,OACCD,EAA0BC,MACrBA,EAAIQ,eCKI,SAA4CxG,GAC1D,IAAOkG,EAAoBlG,KAAeoG,EAAapG,GACtD,OAAO,EAMR,IACC,MAAM,eAAEyG,EAAc,aAAEC,GACiC1G,EACzD,OAIoB,OAAnByG,GAEAA,IAAmBC,CAErB,CAAE,MAAQC,GAGT,OAAO,CACR,CACD,CD5BGC,CAAmCZ,EAAIQ,cAE1C,CENe,SAASK,EAAsBb,GAC7C,QACIA,EAAIQ,gBACLN,EAAoBF,EAAIQ,gBACzBJ,EAAaJ,EAAIQ,gBACjBT,EAA0BC,GAE7B,CCZe,SAASc,EAAkB9G,GAMzC,OAHCA,EAAQmB,cAAc8E,YAGhBjG,EAAQmB,cAAc8E,YAAYa,iBAAkB9G,EAC5D,CCHe,SAAS+G,EAAoBZ,EAAMa,EAAY,YAC7D,GAAOb,EAAP,CAIA,IAAmB,aAAda,GAA0C,QAAdA,IAE3Bb,EAAKc,aAAed,EAAKe,aAAe,CAE5C,MAAM,UAAEC,GAAcL,EAAkBX,GAExC,GAAK,gBAAgBiB,KAAMD,GAC1B,OAAOhB,CAET,CAGD,IAAmB,eAAda,GAA4C,QAAdA,IAE7Bb,EAAKkB,YAAclB,EAAKmB,YAAc,CAE1C,MAAM,UAAEC,GAAcT,EAAkBX,GAExC,GAAK,gBAAgBiB,KAAMG,GAC1B,OAAOpB,CAET,CAGD,OAAKA,EAAKhF,gBAAkBgF,EAAKvB,WACzBuB,EAIDY,EACmBZ,EAAKvB,WAC9BoC,EAjCD,CAmCD,CCpCe,SAASQ,EAAiBrB,GAGxC,IAAIsB,EACJ,MAAUA,EAAuCtB,EAAKvB,aAChD6C,EAAeC,WAAaD,EAAeE,eAKjD,OAAOF,EAQS,WADfX,EAA2CW,GACzCG,SAEKH,EAI8CA,EACpDI,aAdM,IAeT,CCrCe,SAASC,EAAmB9H,GAE1C,MAA2B,UAApBA,EAAQ+H,SAA2C,aAApB/H,EAAQ+H,OAC/C,CCMe,SAASC,EAAoBhI,GAC3C,GAAK8H,EAAmB9H,GACvB,OAC4B,IAA3BA,EAAQyG,gBACRzG,EAAQF,MAAMM,SAAWJ,EAAQ0G,aAInC,IAAO1G,EAAQiI,kBACd,OAAO,EAGR,MAAM,cAAE9G,GAAkBnB,GACpB,YAAEiG,GAAgB9E,EAElBwE,EAAYM,EAAYL,eAExBjC,EAAQgC,EAAUE,WAAaF,EAAUG,WAAY,GAAM,KAEjE,IAAOnC,EACN,OAAO,EAGR,MAAM,eAAEgB,EAAc,aAAEuD,EAAY,YAAEC,EAAW,UAAEC,GAAczE,EAEjE,GACCgB,IAAmB3E,GACnBkI,IAAiBlI,GACD,IAAhBmI,GACAC,IAAcpI,EAAQ6E,WAAWzE,OAEjC,OAAO,EAGUJ,EAAQqI,UAE1B,MAAMC,EACLJ,EAAaR,WAAaQ,EAAaK,UACdL,EAAeM,KAAKpI,OAC1C8H,EAAarD,WAAWzE,OAE5B,OACCqI,EAAa9D,EAAgB3E,EAAS,eACtCyI,EAAaP,EAAclI,EAAS,cACpB,IAAhBmI,GACAC,IAAcE,CAEhB,CAYA,SAASG,EAAaC,EAAOC,EAAWC,GAEvC,IAAIC,EAAYF,EAChB,EAAG,CACF,GAAKD,IAAUG,EACd,OAAO,EAERA,EAAYA,EAAWD,EACxB,OAAUC,GACV,OAAO,CACR,CCtEe,SAASC,EAAe9I,GACtC,IAAOA,EACN,OAAO,EAGR,MAAM,QAAE+H,GAAY/H,EAEpB,OAD8B8H,EAAmB9H,IAEX,WAAZ+H,GAAoC,WAAZA,CAEnD,CCXe,SAASgB,EAAO/I,GAC9B,MAAiD,QAA1C8G,EAAkB9G,GAAUgH,SACpC,CCIe,SAASgC,EAA2BhD,EAAKiD,EAAGC,EAAGP,GAC7D,MAAMQ,EAAiBR,EAAUS,MAAMC,OACjCC,EAAmBX,EAAUS,MAAMxB,UAEnC,SAAEA,EAAW,UAAad,EAAkB6B,GAGhC,WAAbf,IACJe,EAAUS,MAAMxB,SAAW,YAG5Be,EAAUS,MAAMC,OAAS,QAEzB,MAAM1F,ECnBQ,SAA8BqC,EAAKiD,EAAGC,GACpD,GAAKlD,EAAIuD,oBACR,OAAOvD,EAAIuD,oBAAqBN,EAAGC,GAGpC,IAAOlD,EAAIwD,uBACV,OAAO,KAGR,MAAMC,EAAQzD,EAAIwD,uBAAwBP,EAAGC,GAI7C,IAAOO,EACN,OAAO,KAGR,MAAM9F,EAAQqC,EAAIjB,cAKlB,OAHApB,EAAMqB,SAAUyE,EAAMC,WAAYD,EAAME,QACxChG,EAAMiG,UAAU,GAETjG,CACR,CDJe4F,CAAqBvD,EAAKiD,EAAGC,GAK3C,OAHAP,EAAUS,MAAMC,OAASF,EACzBR,EAAUS,MAAMxB,SAAW0B,EAEpB3F,CACR,CE3BO,SAASkG,EAAiBlB,EAAWmB,EAAYC,GACvD,IAAIpG,EAAQoG,IAIZ,OACGpG,GACAA,EAAMgB,gBACNgE,EAAUqB,SAAUrG,EAAMgB,kBAE5BgE,EAAUsB,eAAgBH,GAC1BnG,EAAQoG,IAGLpG,GACAA,EAAMgB,gBACNgE,EAAUqB,SAAUrG,EAAMgB,iBAMvBhB,EAJE,IAKV,CCVe,SAASuG,EAAQvB,EAAWwB,EAAWC,GAAe,GACpE,GACCtC,EAAmBa,IACiB,iBAA7BA,EAAUlC,eAEjB,OAAKkC,EAAUlC,iBAAmBkC,EAAUjC,eAIvCyD,EACgC,IAA7BxB,EAAUlC,eAGXkC,EAAU7I,MAAMM,SAAWuI,EAAUlC,gBAG7C,IAAOkC,EAAUV,kBAChB,OAAO,EAGR,MAAM,cAAE9G,GAAkBwH,GACpB,YAAE1C,GAAgB9E,EAGlBwE,EAAYM,EAAYL,eAE9B,IAAOD,IAAeA,EAAUE,WAC/B,OAAO,EAGR,MAAMlC,EAAQgC,EAAUG,WAAY,GAC9BuE,EAAiB1G,EAAM2B,aACvBgF,ECxCQ,SAA6B3E,GAC3C,MAAM,WAAE4E,EAAU,UAAEC,EAAS,aAAEC,EAAY,YAAEC,GAAgB/E,EAIvDiC,EAAW2C,EAAWjH,wBAAyBkH,GAOrD,QAAK5C,EAAW2C,EAAWhH,kCAItBqE,EAAW2C,EAAW9G,8BAOT,IAAbmE,GACG6C,GAAgBC,EAKzB,CDWmBC,CAAoBhF,GAChCiF,EAAcjF,EAAUiF,YAGvBA,GACNP,EAAeT,UAAYU,GAG5B,MAAMO,EAAqBnH,EAAuB2G,GAC5CS,EAAYpH,EAAuBC,GAEzC,IAAOkH,IAAwBC,EAC9B,OAAO,EAMR,MAAMC,EElEQ,SAAyBpH,GACvC,MAAME,EAAQjD,MAAMC,KAAM8C,EAAMxD,kBAEhC,IAAO0D,EAAMzD,OACZ,OAGD,MAAM4K,EAAaC,KAAKC,OAAQrH,EAAM7C,KAAK,EAAIiD,SAAWA,KAG1D,OAFqBgH,KAAKE,OAAQtH,EAAM7C,KAAK,EAAImD,YAAcA,KAEzC6G,CACvB,CFuDqBI,CAAgBzH,GACpC,IACGiH,GACFG,GACAA,EAAcF,EAAmB1F,QACjCmF,IAAcH,EAEd,OAAO,EAIR,MAAMkB,EAAetC,EAAOJ,IAAgBwB,EAAYA,EAClDmB,EAAgB3C,EAAU3E,wBAY1BiF,EAAIoC,EAAeC,EAAcjH,KAAO,EAAIiH,EAAc/G,MAAQ,EAClE2E,EAAIiB,EAAYmB,EAAcrH,IAAM,EAAIqH,EAAcnH,OAAS,EAC/DoH,EAAY1B,EAAiBlB,EAAWwB,GAAW,IACxDnB,EAA2B7H,EAAe8H,EAAGC,EAAGP,KAGjD,IAAO4C,EACN,OAAO,EAGR,MAAMC,EAAW9H,EAAuB6H,GAExC,IAAOC,EACN,OAAO,EAGR,MAAMC,EAAetB,EAAY,MAAQ,SACnCuB,EAAiBL,EAAe,OAAS,QACzCM,EAAeH,EAAUC,GAAiBX,EAAWW,GACrDG,EACLJ,EAAUE,GAAmBb,EAAoBa,GAG5CG,EAAkBZ,KAAKa,IAAKH,IAAkB,EAC9CI,EAAoBd,KAAKa,IAAKF,IAAoB,EAExD,OAAOxB,EACJyB,EACAA,GAAmBE,CACvB,CGjHe,SAASC,EAAkBrD,EAAWwB,GACpD,OAAOD,EAAQvB,EAAWwB,EAC3B,C,mFCfA,MAAM,EAA+B1F,OAAW,GAAc,W,aCkB/C,SAASwH,EAAe9F,GAMtC,OALA+F,IAAY,uBAAwB,CACnCC,MAAO,MACPC,QAAS,QAITlG,EAAoBC,IACN,WAAdA,EAAKzD,OACH2J,MAAOlG,EAAKmG,cAEhB,CChBe,SAASC,EAAgB5D,EAAWwB,GAClD,OAAOD,EAAQvB,EAAWwB,GAAW,EACtC,CC8Be,SAASqC,EAAkB7D,EAAWwB,EAAWlB,GAC/D,IAAON,EACN,OAKD,GAFAA,EAAU8D,QAEL3E,EAAmBa,GAAc,CAErC,GAAyC,iBAA7BA,EAAUlC,eACrB,OAWD,YARK0D,GACJxB,EAAUlC,eAAiBkC,EAAU7I,MAAMM,OAC3CuI,EAAUjC,aAAeiC,EAAU7I,MAAMM,SAEzCuI,EAAUlC,eAAiB,EAC3BkC,EAAUjC,aAAe,GAI3B,CAEA,IAAOiC,EAAUV,kBAChB,OAGD,MAAMtE,EAAQkG,EAAiBlB,EAAWwB,GAAW,IAvDtD,SAAmBxB,EAAWwB,EAAWlB,GACxC,MAAM,cAAE9H,GAAkBwH,EAEpB0C,EAAetC,EAAOJ,IAAgBwB,EAAYA,EAClDmB,EAAgB3C,EAAU3E,wBAahC,YARW0I,IAANzD,EACJA,EAAIkB,EAAYmB,EAAc/G,MAAQ,EAAI+G,EAAcjH,KAAO,EACpD4E,GAAKqC,EAAcjH,KAC9B4E,EAAIqC,EAAcjH,KAAO,EACd4E,GAAKqC,EAAc/G,QAC9B0E,EAAIqC,EAAc/G,MAAQ,GAGpByE,EAA2B7H,EAAe8H,EADvCoC,EAAeC,EAAcnH,OAAS,EAAImH,EAAcrH,IAAM,EACjB0E,EACxD,CAsCEgE,CAAUhE,EAAWwB,EAAWlB,KAGjC,IAAOtF,EAAQ,OAEf,MAAM,cAAExC,GAAkBwH,GACpB,YAAE1C,GAAgB9E,EAElBwE,EAAYM,EAAYL,eAE9BD,EAAUiH,kBACVjH,EAAUkH,SAAUlJ,EACrB,CC3Ee,SAASmJ,EAA4BnE,EAAWwB,GAC9D,OAAOqC,EAAkB7D,EAAWwB,OAAWuC,EAChD,CCDe,SAASK,EAA0BpE,EAAWwB,EAAWjF,GACvE,OAAOsH,EAAkB7D,EAAWwB,EAAWjF,GAAMb,KACtD,CCDe,SAAS2I,EAAaC,EAASC,GAC5BA,EAActI,WAC/BsI,EAActI,WAAWuI,aAAcF,EAASC,EAAcE,YAC/D,CCLe,SAASC,EAAQlH,GACdA,EAAKvB,WACtBuB,EAAKvB,WAAWY,YAAaW,EAC9B,CCAe,SAASmH,EAASC,EAAeN,GAC9BM,EAAc3I,WAC/BoI,EAAaC,EAASM,EAAc3I,YACpCyI,EAAQE,EACT,CCNe,SAASC,EAAQrH,GAC/B,MAAMsH,EAAStH,EAAKvB,WAIpB,KAAQuB,EAAKuH,YACZD,EAAON,aAAchH,EAAKuH,WAAYvH,GAGvCsH,EAAOjI,YAAaW,EACrB,CCTe,SAASwH,EAAYxH,EAAM4B,GACzC,MAAMkF,EAAU9G,EAAKhF,cAAcyM,cAAe7F,GAElD,KAAQ5B,EAAKuH,YACZT,EAAQY,YAAa1H,EAAKuH,YAM3B,OAHiBvH,EAAKvB,WACtBuB,EAAKvB,WAAWkJ,aAAcb,EAAS9G,GAEhC8G,CACR,CCbe,SAASc,EAAMd,EAASC,GACrBA,EAActI,WAC/BsI,EAActI,WAAWuI,aAAcF,EAASC,GAChDD,EAAQY,YAAaX,EACtB,CCHe,SAASc,EAAUC,GACjC,MAAM,KAAE9K,GAAS+K,SAASC,eAAeC,mBAAoB,IAC7DjL,EAAKkL,UAAYJ,EACjB,MAAMzN,EAAW2C,EAAKmL,qBAAsB,KAC5C,IAAIC,EAAe/N,EAASJ,OAE5B,KAAQmO,KAAiB,CACxB,MAAMvO,EAAUQ,EAAU+N,GAE1B,GAAyB,WAApBvO,EAAQ+H,QACZsF,EAAQrN,OACF,CACN,IAAIwO,EAAiBxO,EAAQyO,WAAWrO,OAExC,KAAQoO,KAAmB,CAC1B,MAAQnN,KAAMpC,GAAQe,EAAQyO,WAAYD,GAErCvP,EAAIyP,WAAY,OACpB1O,EAAQ2O,gBAAiB1P,EAE3B,CACD,CACD,CAEA,OAAOkE,EAAKkL,SACb,CCzBe,SAASO,EAAWX,GAGlCA,EAAOD,EAAUC,GAEjB,MAAMjI,EAAMkI,SAASC,eAAeC,mBAAoB,IAExD,OADApI,EAAI7C,KAAKkL,UAAYJ,EACdjI,EAAI7C,KAAK0L,aAAe,EAChC,CCZe,SAASC,EAAS9O,GAChC,OAASA,EAAQ0H,UAChB,KAAK1H,EAAQuI,UAGZ,MAAO,yBAAyBnB,KAAMpH,EAAQ+O,WAAa,IAC5D,KAAK/O,EAAQ2H,aACZ,OAAK3H,EAAQgP,mBAEChP,EAAQiP,iBAKrBrO,MAAMC,KAAMb,EAAQ6E,YACnBqK,MAAOJ,IACV,QACC,OAAO,EAEV,CCJA,MAAMK,EAAoB,CACzBC,OAAQ,CAAC,EACTC,GAAI,CAAC,EACLC,EAAG,CAAC,EACJC,IAAK,CAAC,EACNC,IAAK,CAAC,EACN1Q,EAAG,CAAE2P,WAAY,CAAE,OAAQ,SAAU,MAAO,OAC5CgB,KAAM,CAAC,EACPC,KAAM,CAAEjB,WAAY,CAAE,UACtBkB,IAAK,CAAC,EACNC,IAAK,CAAC,EACNC,GAAI,CAAC,EACLC,MAAO,CAAC,EAGRC,EAAG,CAAEtB,WAAY,CAAE,SACnBuB,IAAK,CAAEvB,WAAY,CAAE,UACrBjG,KAAM,CAAEiG,WAAY,CAAE,UACtBwB,KAAM,CAAExB,WAAY,CAAE,aACtByB,IAAK,CAAC,EACNC,KAAM,CAAC,EACPC,IAAK,CAAC,EACNC,EAAG,CAAC,EACJpO,EAAG,CAAC,EACJqO,EAAG,CAAC,EACJC,KAAM,CAAC,EACPC,KAAM,CAAC,EACPC,GAAI,CAAC,EACLC,GAAI,CAAC,EACLC,IAAK,CAAElC,WAAY,CAAE,QACrBmC,IAAK,CAAEnC,WAAY,CAAE,QACrBoC,IAAK,CAAC,EACN,QAAS,CAAC,GAMLC,EAAmB,CAAE,QAAS,MACpC3R,OAAO4R,KAAM5B,GACXrO,QAAUd,IAAe8Q,EAAiBzK,SAAUrG,KACpDgR,SAAWC,IACX,MAAQ,CAAEA,GAAOC,KAAeC,GAAehC,EAC/CA,EAAmB8B,GAAMG,SAAWD,CAAU,IAUhD,MAyDME,EAAwB,IAC1BlC,EAzDHmC,MAAO,CACN7C,WAAY,CACX,MACA,UACA,WACA,aACA,OACA,UAGF8C,OAAQ,CAAE9C,WAAY,CAAE,QAAS,WACjC+C,MAAO,CAAE/C,WAAY,CAAE,MAAO,OAAQ,QAAS,WAC/CvN,IAAK,CACJuN,WAAY,CACX,MACA,MACA,SACA,SACA,QACA,QACA,WAGF1M,OAAQ,CACP0M,WAAY,CACX,OACA,OACA,OACA,SACA,OACA,QACA,WAGFgD,MAAO,CACNhD,WAAY,CACX,MACA,SACA,UACA,cACA,WACA,aACA,OACA,QACA,WACA,QACA,YAyBI,SAASiD,EAA0BpR,GACzC,GAAiB,UAAZA,EACJ,OAAO+Q,EAMR,MAAM,EACLf,EAAC,KACDZ,EAAI,KACJlH,EAAI,KACJyH,EAAI,IACJY,EAAG,IACHF,EAAG,IACHC,KACGe,GACA,IACAN,EAGH7B,IAAK,CAAE4B,SAAUC,EAAsB7B,IAAI4B,UAC3C7B,IAAK,CAAE6B,SAAUC,EAAsB9B,IAAI6B,WAG5C,OAAOO,CACR,CAWO,SAASC,GAAmBzL,GAClC,MAAM8K,EAAM9K,EAAKpF,SAAS8Q,cAC1B,OAAOH,IAA2BhS,eAAgBuR,IAAiB,SAARA,CAC5D,CAMO,SAASa,GAAe3L,GAC9B,MAAM8K,EAAM9K,EAAKpF,SAAS8Q,cAC1B,OAAO1C,EAAkBzP,eAAgBuR,IAAiB,SAARA,CACnD,CC3LA,MAAMc,GAAOA,OAyBE,SAASC,GAAeC,EAAUjM,EAAKkM,EAAQC,GAC7DvR,MAAMC,KAAMoR,GAAWjB,SACmC7K,IACxD,MAAM8K,EAAM9K,EAAKpF,SAAS8Q,cAI1B,IACCK,EAAOxS,eAAgBuR,IACnBiB,EAAQjB,GAAMmB,UAAWF,EAAQjB,GAAMmB,UAAWjM,GA6HtD6L,GAAe7L,EAAKtB,WAAYmB,EAAKkM,EAAQC,GAK5CA,IACEP,GAAmBzL,IACrBA,EAAKkM,oBAELrF,EAAahH,EAAI4H,cAAe,MAAQzH,GAGzCqH,EAAQrH,QAvIR,GCzCW,SAAoBA,GAElC,QAAUA,GAAQA,EAAKuB,WAAavB,EAAKwB,YAC1C,CDsCS2K,CAAWnM,GAAS,CACxB,MAAM,WACLsI,EAAa,GAAE,QACf8D,EAAU,GAAE,SACZnB,EAAQ,QACRoB,EAAU,GAAE,WACZC,GACGP,EAAQjB,GAIZ,GAAKG,IAAcqB,GAAc3D,EAAS3I,GAEzC,YADAkH,EAAQlH,GAIT,GAAKA,EAAK6I,kBAETpO,MAAMC,KAAMsF,EAAKsI,YAAauC,SAAS,EAAI3P,WAEhC,UAATA,GACEoN,EAAWpI,SAAUhF,IAEvB8E,EAAKwI,gBAAiBtN,EACvB,IAMI8E,EAAKuM,WAAavM,EAAKuM,UAAUtS,QAAS,CAC9C,MAAMuS,EAAYJ,EAAQvR,KAAO4R,GACX,iBAATA,EAEYC,GAClBA,IAAcD,EACRA,aAAgBE,OAEJD,GAClBD,EAAKxL,KAAMyL,GAGVd,KAGRnR,MAAMC,KAAMsF,EAAKuM,WAAY1B,SAAW3P,IAEpCsR,EAAUI,MAAQX,GACnBA,EAAS/Q,MAGV8E,EAAKuM,UAAUrF,OAAQhM,EACxB,IAGM8E,EAAKuM,UAAUtS,QACrB+F,EAAKwI,gBAAiB,QAExB,CAGD,GAAKxI,EAAK8I,gBAAkB,CAE3B,GAAkB,MAAbmC,EACJ,OAID,GAAKA,EAIHoB,EAAQpS,SACN+F,EAAK/E,cAAeoR,EAAQ9R,KAAM,OAEpCsR,GACC7L,EAAKtB,WACLmB,EACAkM,EACAC,GAED3E,EAAQrH,IAKRA,EAAKvB,YACwB,SAA7BuB,EAAKvB,WAAW7D,UAChB6Q,GAAmBzL,IAEnB6L,GACC7L,EAAKtB,WACLmB,EACAkM,EACAC,GAIAvR,MAAMC,KAAMsF,EAAKtB,YAAakO,MAC3BC,IACCpB,GAAmBoB,MAGvBxF,EAAQrH,IAGT6L,GACC7L,EAAKtB,WACLmB,EACAoL,EACAe,QAKF,KAAQhM,EAAKuH,YACZL,EAAQlH,EAAKuH,WAGhB,CACD,CAgBD,GAGH,CE3Ke,SAASuF,GAAmBC,EAAMhB,EAAQC,GACxD,MAAMnM,EAAMkI,SAASC,eAAeC,mBAAoB,IAMxD,OAJApI,EAAI7C,KAAKkL,UAAY6E,EAErBlB,GAAehM,EAAI7C,KAAK0B,WAAYmB,EAAKkM,EAAQC,GAE1CnM,EAAI7C,KAAKkL,SACjB,CCfO,SAAS8E,GAA0BC,GACzC,MAAMC,EAAQzS,MAAMC,KAAMuS,EAAaC,OAkBvC,OAhBAzS,MAAMC,KAAMuS,EAAaE,OAAQtC,SAAW4B,IAC3C,MAAMW,EAAOX,EAAKY,YAGjBD,IACEF,EAAMhT,MACP,EAAIgB,OAAMqB,OAAM+Q,UACfpS,IAASkS,EAAKlS,MACdqB,IAAS6Q,EAAK7Q,MACd+Q,IAASF,EAAKE,QAGhBJ,EAAMK,KAAMH,EACb,IAGMF,CACR,CCjBO,MAAM5G,GAAQ,CAAEpJ,UAAS,EAAEsQ,SAAQA,I","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/compat get default export","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","../../packages/dom/src/focusable.js","../../packages/dom/src/tabbable.js","../../packages/dom/src/dom/get-rectangle-from-range.js","../../packages/dom/src/dom/compute-caret-rect.js","../../packages/dom/src/dom/document-has-text-selection.js","../../packages/dom/src/dom/is-html-input-element.js","../../packages/dom/src/dom/is-text-field.js","../../packages/dom/src/dom/document-has-uncollapsed-selection.js","../../packages/dom/src/dom/input-field-has-uncollapsed-selection.js","../../packages/dom/src/dom/document-has-selection.js","../../packages/dom/src/dom/get-computed-style.js","../../packages/dom/src/dom/get-scroll-container.js","../../packages/dom/src/dom/get-offset-parent.js","../../packages/dom/src/dom/is-input-or-text-area.js","../../packages/dom/src/dom/is-entirely-selected.js","../../packages/dom/src/dom/is-form-element.js","../../packages/dom/src/dom/is-rtl.js","../../packages/dom/src/dom/hidden-caret-range-from-point.js","../../packages/dom/src/dom/caret-range-from-point.js","../../packages/dom/src/dom/scroll-if-no-range.js","../../packages/dom/src/dom/is-edge.js","../../packages/dom/src/dom/is-selection-forward.js","../../packages/dom/src/dom/get-range-height.js","../../packages/dom/src/dom/is-horizontal-edge.js","webpack://wp/external window [\"wp\",\"deprecated\"]","../../packages/dom/src/dom/is-number-input.js","../../packages/dom/src/dom/is-vertical-edge.js","../../packages/dom/src/dom/place-caret-at-edge.js","../../packages/dom/src/dom/place-caret-at-horizontal-edge.js","../../packages/dom/src/dom/place-caret-at-vertical-edge.js","../../packages/dom/src/dom/insert-after.js","../../packages/dom/src/dom/remove.js","../../packages/dom/src/dom/replace.js","../../packages/dom/src/dom/unwrap.js","../../packages/dom/src/dom/replace-tag.js","../../packages/dom/src/dom/wrap.js","../../packages/dom/src/dom/safe-html.js","../../packages/dom/src/dom/strip-html.js","../../packages/dom/src/dom/is-empty.js","../../packages/dom/src/phrasing-content.js","../../packages/dom/src/dom/clean-node-list.js","../../packages/dom/src/dom/is-element.js","../../packages/dom/src/dom/remove-invalid-html.js","../../packages/dom/src/data-transfer.js","../../packages/dom/src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * References:\n *\n * Focusable:\n *  - https://www.w3.org/TR/html5/editing.html#focus-management\n *\n * Sequential focus navigation:\n *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\n *\n * Disabled elements:\n *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\n *\n * getClientRects algorithm (requiring layout box):\n *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\n *\n * AREA elements associated with an IMG:\n *  - https://w3c.github.io/html/editing.html#data-model\n */\n\n/**\n * Returns a CSS selector used to query for focusable elements.\n *\n * @param {boolean} sequential If set, only query elements that are sequentially\n *                             focusable. Non-interactive elements with a\n *                             negative `tabindex` are focusable but not\n *                             sequentially focusable.\n *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {string} CSS selector.\n */\nfunction buildSelector( sequential ) {\n\treturn [\n\t\tsequential ? '[tabindex]:not([tabindex^=\"-\"])' : '[tabindex]',\n\t\t'a[href]',\n\t\t'button:not([disabled])',\n\t\t'input:not([type=\"hidden\"]):not([disabled])',\n\t\t'select:not([disabled])',\n\t\t'textarea:not([disabled])',\n\t\t'iframe:not([tabindex^=\"-\"])',\n\t\t'object',\n\t\t'embed',\n\t\t'area[href]',\n\t\t'[contenteditable]:not([contenteditable=false])',\n\t].join( ',' );\n}\n\n/**\n * Returns true if the specified element is visible (i.e. neither display: none\n * nor visibility: hidden).\n *\n * @param {HTMLElement} element DOM element to test.\n *\n * @return {boolean} Whether element is visible.\n */\nfunction isVisible( element ) {\n\treturn (\n\t\telement.offsetWidth > 0 ||\n\t\telement.offsetHeight > 0 ||\n\t\telement.getClientRects().length > 0\n\t);\n}\n\n/**\n * Returns true if the specified area element is a valid focusable element, or\n * false otherwise. Area is only focusable if within a map where a named map\n * referenced by an image somewhere in the document.\n *\n * @param {HTMLAreaElement} element DOM area element to test.\n *\n * @return {boolean} Whether area element is valid for focus.\n */\nfunction isValidFocusableArea( element ) {\n\t/** @type {HTMLMapElement | null} */\n\tconst map = element.closest( 'map[name]' );\n\tif ( ! map ) {\n\t\treturn false;\n\t}\n\n\t/** @type {HTMLImageElement | null} */\n\tconst img = element.ownerDocument.querySelector(\n\t\t'img[usemap=\"#' + map.name + '\"]'\n\t);\n\treturn !! img && isVisible( img );\n}\n\n/**\n * Returns all focusable elements within a given context.\n *\n * @param {Element} context              Element in which to search.\n * @param {Object}  options\n * @param {boolean} [options.sequential] If set, only return elements that are\n *                                       sequentially focusable.\n *                                       Non-interactive elements with a\n *                                       negative `tabindex` are focusable but\n *                                       not sequentially focusable.\n *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute\n *\n * @return {HTMLElement[]} Focusable elements.\n */\nexport function find( context, { sequential = false } = {} ) {\n\t/** @type {NodeListOf<HTMLElement>} */\n\tconst elements = context.querySelectorAll( buildSelector( sequential ) );\n\n\treturn Array.from( elements ).filter( ( element ) => {\n\t\tif ( ! isVisible( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { nodeName } = element;\n\t\tif ( 'AREA' === nodeName ) {\n\t\t\treturn isValidFocusableArea(\n\t\t\t\t/** @type {HTMLAreaElement} */ ( element )\n\t\t\t);\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n","/**\n * Internal dependencies\n */\nimport { find as findFocusable } from './focusable';\n\n/**\n * Returns the tab index of the given element. In contrast with the tabIndex\n * property, this normalizes the default (0) to avoid browser inconsistencies,\n * operating under the assumption that this function is only ever called with a\n * focusable node.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\n *\n * @param {Element} element Element from which to retrieve.\n *\n * @return {number} Tab index of element (default 0).\n */\nfunction getTabIndex( element ) {\n\tconst tabIndex = element.getAttribute( 'tabindex' );\n\treturn tabIndex === null ? 0 : parseInt( tabIndex, 10 );\n}\n\n/**\n * Returns true if the specified element is tabbable, or false otherwise.\n *\n * @param {Element} element Element to test.\n *\n * @return {boolean} Whether element is tabbable.\n */\nexport function isTabbableIndex( element ) {\n\treturn getTabIndex( element ) !== -1;\n}\n\n/** @typedef {HTMLElement & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */\n\n/**\n * Returns a stateful reducer function which constructs a filtered array of\n * tabbable elements, where at most one radio input is selected for a given\n * name, giving priority to checked input, falling back to the first\n * encountered.\n *\n * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.\n */\nfunction createStatefulCollapseRadioGroup() {\n\t/** @type {Record<string, MaybeHTMLInputElement>} */\n\tconst CHOSEN_RADIO_BY_NAME = {};\n\n\treturn function collapseRadioGroup(\n\t\t/** @type {MaybeHTMLInputElement[]} */ result,\n\t\t/** @type {MaybeHTMLInputElement} */ element\n\t) {\n\t\tconst { nodeName, type, checked, name } = element;\n\n\t\t// For all non-radio tabbables, construct to array by concatenating.\n\t\tif ( nodeName !== 'INPUT' || type !== 'radio' || ! name ) {\n\t\t\treturn result.concat( element );\n\t\t}\n\n\t\tconst hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty( name );\n\n\t\t// Omit by skipping concatenation if the radio element is not chosen.\n\t\tconst isChosen = checked || ! hasChosen;\n\t\tif ( ! isChosen ) {\n\t\t\treturn result;\n\t\t}\n\n\t\t// At this point, if there had been a chosen element, the current\n\t\t// element is checked and should take priority. Retroactively remove\n\t\t// the element which had previously been considered the chosen one.\n\t\tif ( hasChosen ) {\n\t\t\tconst hadChosenElement = CHOSEN_RADIO_BY_NAME[ name ];\n\t\t\tresult = result.filter( ( e ) => e !== hadChosenElement );\n\t\t}\n\n\t\tCHOSEN_RADIO_BY_NAME[ name ] = element;\n\n\t\treturn result.concat( element );\n\t};\n}\n\n/**\n * An array map callback, returning an object with the element value and its\n * array index location as properties. This is used to emulate a proper stable\n * sort where equal tabIndex should be left in order of their occurrence in the\n * document.\n *\n * @param {HTMLElement} element Element.\n * @param {number}      index   Array index of element.\n *\n * @return {{ element: HTMLElement, index: number }} Mapped object with element, index.\n */\nfunction mapElementToObjectTabbable( element, index ) {\n\treturn { element, index };\n}\n\n/**\n * An array map callback, returning an element of the given mapped object's\n * element value.\n *\n * @param {{ element: HTMLElement }} object Mapped object with element.\n *\n * @return {HTMLElement} Mapped object element.\n */\nfunction mapObjectTabbableToElement( object ) {\n\treturn object.element;\n}\n\n/**\n * A sort comparator function used in comparing two objects of mapped elements.\n *\n * @see mapElementToObjectTabbable\n *\n * @param {{ element: HTMLElement, index: number }} a First object to compare.\n * @param {{ element: HTMLElement, index: number }} b Second object to compare.\n *\n * @return {number} Comparator result.\n */\nfunction compareObjectTabbables( a, b ) {\n\tconst aTabIndex = getTabIndex( a.element );\n\tconst bTabIndex = getTabIndex( b.element );\n\n\tif ( aTabIndex === bTabIndex ) {\n\t\treturn a.index - b.index;\n\t}\n\n\treturn aTabIndex - bTabIndex;\n}\n\n/**\n * Givin focusable elements, filters out tabbable element.\n *\n * @param {HTMLElement[]} focusables Focusable elements to filter.\n *\n * @return {HTMLElement[]} Tabbable elements.\n */\nfunction filterTabbable( focusables ) {\n\treturn focusables\n\t\t.filter( isTabbableIndex )\n\t\t.map( mapElementToObjectTabbable )\n\t\t.sort( compareObjectTabbables )\n\t\t.map( mapObjectTabbableToElement )\n\t\t.reduce( createStatefulCollapseRadioGroup(), [] );\n}\n\n/**\n * @param {Element} context\n * @return {HTMLElement[]} Tabbable elements within the context.\n */\nexport function find( context ) {\n\treturn filterTabbable( findFocusable( context ) );\n}\n\n/**\n * Given a focusable element, find the preceding tabbable element.\n *\n * @param {Element} element The focusable element before which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Preceding tabbable element.\n */\nexport function findPrevious( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) )\n\t\t.reverse()\n\t\t.find(\n\t\t\t( focusable ) =>\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\t\telement.DOCUMENT_POSITION_PRECEDING\n\t\t);\n}\n\n/**\n * Given a focusable element, find the next tabbable element.\n *\n * @param {Element} element The focusable element after which to look. Defaults\n *                          to the active element.\n *\n * @return {HTMLElement|undefined} Next tabbable element.\n */\nexport function findNext( element ) {\n\treturn filterTabbable( findFocusable( element.ownerDocument.body ) ).find(\n\t\t( focusable ) =>\n\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\telement.compareDocumentPosition( focusable ) &\n\t\t\telement.DOCUMENT_POSITION_FOLLOWING\n\t);\n}\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Get the rectangle of a given Range. Returns `null` if no suitable rectangle\r\n * can be found.\r\n *\r\n * @param {Range} range The range.\r\n *\r\n * @return {DOMRect?} The rectangle.\r\n */\r\nexport default function getRectangleFromRange( range ) {\r\n\t// For uncollapsed ranges, get the rectangle that bounds the contents of the\r\n\t// range; this a rectangle enclosing the union of the bounding rectangles\r\n\t// for all the elements in the range.\r\n\tif ( ! range.collapsed ) {\r\n\t\tconst rects = Array.from( range.getClientRects() );\r\n\r\n\t\t// If there's just a single rect, return it.\r\n\t\tif ( rects.length === 1 ) {\r\n\t\t\treturn rects[ 0 ];\r\n\t\t}\r\n\r\n\t\t// Ignore tiny selection at the edge of a range.\r\n\t\tconst filteredRects = rects.filter( ( { width } ) => width > 1 );\r\n\r\n\t\t// If it's full of tiny selections, return browser default.\r\n\t\tif ( filteredRects.length === 0 ) {\r\n\t\t\treturn range.getBoundingClientRect();\r\n\t\t}\r\n\r\n\t\tif ( filteredRects.length === 1 ) {\r\n\t\t\treturn filteredRects[ 0 ];\r\n\t\t}\r\n\r\n\t\tlet {\r\n\t\t\ttop: furthestTop,\r\n\t\t\tbottom: furthestBottom,\r\n\t\t\tleft: furthestLeft,\r\n\t\t\tright: furthestRight,\r\n\t\t} = filteredRects[ 0 ];\r\n\r\n\t\tfor ( const { top, bottom, left, right } of filteredRects ) {\r\n\t\t\tif ( top < furthestTop ) furthestTop = top;\r\n\t\t\tif ( bottom > furthestBottom ) furthestBottom = bottom;\r\n\t\t\tif ( left < furthestLeft ) furthestLeft = left;\r\n\t\t\tif ( right > furthestRight ) furthestRight = right;\r\n\t\t}\r\n\r\n\t\treturn new window.DOMRect(\r\n\t\t\tfurthestLeft,\r\n\t\t\tfurthestTop,\r\n\t\t\tfurthestRight - furthestLeft,\r\n\t\t\tfurthestBottom - furthestTop\r\n\t\t);\r\n\t}\r\n\r\n\tconst { startContainer } = range;\r\n\tconst { ownerDocument } = startContainer;\r\n\r\n\t// Correct invalid \"BR\" ranges. The cannot contain any children.\r\n\tif ( startContainer.nodeName === 'BR' ) {\r\n\t\tconst { parentNode } = startContainer;\r\n\t\tassertIsDefined( parentNode, 'parentNode' );\r\n\t\tconst index = /** @type {Node[]} */ (\r\n\t\t\tArray.from( parentNode.childNodes )\r\n\t\t).indexOf( startContainer );\r\n\r\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\r\n\t\trange = ownerDocument.createRange();\r\n\t\trange.setStart( parentNode, index );\r\n\t\trange.setEnd( parentNode, index );\r\n\t}\r\n\r\n\tconst rects = range.getClientRects();\r\n\r\n\t// If we have multiple rectangles for a collapsed range, there's no way to\r\n\t// know which it is, so don't return anything.\r\n\tif ( rects.length > 1 ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet rect = rects[ 0 ];\r\n\r\n\t// If the collapsed range starts (and therefore ends) at an element node,\r\n\t// `getClientRects` can be empty in some browsers. This can be resolved\r\n\t// by adding a temporary text node with zero-width space to the range.\r\n\t//\r\n\t// See: https://stackoverflow.com/a/6847328/995445\r\n\tif ( ! rect || rect.height === 0 ) {\r\n\t\tassertIsDefined( ownerDocument, 'ownerDocument' );\r\n\t\tconst padNode = ownerDocument.createTextNode( '\\u200b' );\r\n\t\t// Do not modify the live range.\r\n\t\trange = range.cloneRange();\r\n\t\trange.insertNode( padNode );\r\n\t\trect = range.getClientRects()[ 0 ];\r\n\t\tassertIsDefined( padNode.parentNode, 'padNode.parentNode' );\r\n\t\tpadNode.parentNode.removeChild( padNode );\r\n\t}\r\n\r\n\treturn rect;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport getRectangleFromRange from './get-rectangle-from-range';\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Get the rectangle for the selection in a container.\r\n *\r\n * @param {Window} win The window of the selection.\r\n *\r\n * @return {DOMRect | null} The rectangle.\r\n */\r\nexport default function computeCaretRect( win ) {\r\n\tconst selection = win.getSelection();\r\n\tassertIsDefined( selection, 'selection' );\r\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\r\n\r\n\tif ( ! range ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn getRectangleFromRange( range );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Check whether the current document has selected text. This applies to ranges\r\n * of text in the document, and not selection inside `<input>` and `<textarea>`\r\n * elements.\r\n *\r\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection#Related_objects.\r\n *\r\n * @param {Document} doc The document to check.\r\n *\r\n * @return {boolean} True if there is selection, false if not.\r\n */\r\nexport default function documentHasTextSelection( doc ) {\r\n\tassertIsDefined( doc.defaultView, 'doc.defaultView' );\r\n\tconst selection = doc.defaultView.getSelection();\r\n\tassertIsDefined( selection, 'selection' );\r\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\r\n\treturn !! range && ! range.collapsed;\r\n}\r\n","/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @param {Node} node\r\n * @return {node is HTMLInputElement} Whether the node is an HTMLInputElement.\r\n */\r\nexport default function isHTMLInputElement( node ) {\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\treturn node?.nodeName === 'INPUT';\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isHTMLInputElement from './is-html-input-element';\r\n\r\n/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * Check whether the given element is a text field, where text field is defined\r\n * by the ability to select within the input, or that it is contenteditable.\r\n *\r\n * See: https://html.spec.whatwg.org/#textFieldSelection\r\n *\r\n * @param {Node} node The HTML element.\r\n * @return {node is HTMLElement} True if the element is an text field, false if not.\r\n */\r\nexport default function isTextField( node ) {\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\tconst nonTextInputs = [\r\n\t\t'button',\r\n\t\t'checkbox',\r\n\t\t'hidden',\r\n\t\t'file',\r\n\t\t'radio',\r\n\t\t'image',\r\n\t\t'range',\r\n\t\t'reset',\r\n\t\t'submit',\r\n\t\t'number',\r\n\t\t'email',\r\n\t\t'time',\r\n\t];\r\n\treturn (\r\n\t\t( isHTMLInputElement( node ) &&\r\n\t\t\tnode.type &&\r\n\t\t\t! nonTextInputs.includes( node.type ) ) ||\r\n\t\tnode.nodeName === 'TEXTAREA' ||\r\n\t\t/** @type {HTMLElement} */ ( node ).contentEditable === 'true'\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport documentHasTextSelection from './document-has-text-selection';\r\nimport inputFieldHasUncollapsedSelection from './input-field-has-uncollapsed-selection';\r\n\r\n/**\r\n * Check whether the current document has any sort of (uncollapsed) selection.\r\n * This includes ranges of text across elements and any selection inside\r\n * textual `<input>` and `<textarea>` elements.\r\n *\r\n * @param {Document} doc The document to check.\r\n *\r\n * @return {boolean} Whether there is any recognizable text selection in the document.\r\n */\r\nexport default function documentHasUncollapsedSelection( doc ) {\r\n\treturn (\r\n\t\tdocumentHasTextSelection( doc ) ||\r\n\t\t( !! doc.activeElement &&\r\n\t\t\tinputFieldHasUncollapsedSelection( doc.activeElement ) )\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isTextField from './is-text-field';\r\nimport isHTMLInputElement from './is-html-input-element';\r\n\r\n/**\r\n * Check whether the given input field or textarea contains a (uncollapsed)\r\n * selection of text.\r\n *\r\n * CAVEAT: Only specific text-based HTML inputs support the selection APIs\r\n * needed to determine whether they have a collapsed or uncollapsed selection.\r\n * This function defaults to returning `true` when the selection cannot be\r\n * inspected, such as with `<input type=\"time\">`. The rationale is that this\r\n * should cause the block editor to defer to the browser's native selection\r\n * handling (e.g. copying and pasting), thereby reducing friction for the user.\r\n *\r\n * See: https://html.spec.whatwg.org/multipage/input.html#do-not-apply\r\n *\r\n * @param {Element} element The HTML element.\r\n *\r\n * @return {boolean} Whether the input/textareaa element has some \"selection\".\r\n */\r\nexport default function inputFieldHasUncollapsedSelection( element ) {\r\n\tif ( ! isHTMLInputElement( element ) && ! isTextField( element ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Safari throws a type error when trying to get `selectionStart` and\r\n\t// `selectionEnd` on non-text <input> elements, so a try/catch construct is\r\n\t// necessary.\r\n\ttry {\r\n\t\tconst { selectionStart, selectionEnd } =\r\n\t\t\t/** @type {HTMLInputElement | HTMLTextAreaElement} */ ( element );\r\n\t\treturn (\r\n\t\t\t// `null` means the input type doesn't implement selection, thus we\r\n\t\t\t// cannot determine whether the selection is collapsed, so we\r\n\t\t\t// default to true.\r\n\t\t\tselectionStart === null ||\r\n\t\t\t// when not null, compare the two points\r\n\t\t\tselectionStart !== selectionEnd\r\n\t\t);\r\n\t} catch ( error ) {\r\n\t\t// This is Safari's way of saying that the input type doesn't implement\r\n\t\t// selection, so we default to true.\r\n\t\treturn true;\r\n\t}\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isTextField from './is-text-field';\r\nimport isHTMLInputElement from './is-html-input-element';\r\nimport documentHasTextSelection from './document-has-text-selection';\r\n\r\n/**\r\n * Check whether the current document has a selection. This includes focus in\r\n * input fields, textareas, and general rich-text selection.\r\n *\r\n * @param {Document} doc The document to check.\r\n *\r\n * @return {boolean} True if there is selection, false if not.\r\n */\r\nexport default function documentHasSelection( doc ) {\r\n\treturn (\r\n\t\t!! doc.activeElement &&\r\n\t\t( isHTMLInputElement( doc.activeElement ) ||\r\n\t\t\tisTextField( doc.activeElement ) ||\r\n\t\t\tdocumentHasTextSelection( doc ) )\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @param {Element} element\r\n * @return {ReturnType<Window['getComputedStyle']>} The computed style for the element.\r\n */\r\nexport default function getComputedStyle( element ) {\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\tassertIsDefined(\r\n\t\telement.ownerDocument.defaultView,\r\n\t\t'element.ownerDocument.defaultView'\r\n\t);\r\n\treturn element.ownerDocument.defaultView.getComputedStyle( element );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport getComputedStyle from './get-computed-style';\r\n\r\n/**\r\n * Given a DOM node, finds the closest scrollable container node or the node\r\n * itself, if scrollable.\r\n *\r\n * @param {Element | null} node      Node from which to start.\r\n * @param {?string}        direction Direction of scrollable container to search for ('vertical', 'horizontal', 'all').\r\n *                                   Defaults to 'vertical'.\r\n * @return {Element | undefined} Scrollable container node, if found.\r\n */\r\nexport default function getScrollContainer( node, direction = 'vertical' ) {\r\n\tif ( ! node ) {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tif ( direction === 'vertical' || direction === 'all' ) {\r\n\t\t// Scrollable if scrollable height exceeds displayed...\r\n\t\tif ( node.scrollHeight > node.clientHeight ) {\r\n\t\t\t// ...except when overflow is defined to be hidden or visible\r\n\t\t\tconst { overflowY } = getComputedStyle( node );\r\n\r\n\t\t\tif ( /(auto|scroll)/.test( overflowY ) ) {\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( direction === 'horizontal' || direction === 'all' ) {\r\n\t\t// Scrollable if scrollable width exceeds displayed...\r\n\t\tif ( node.scrollWidth > node.clientWidth ) {\r\n\t\t\t// ...except when overflow is defined to be hidden or visible\r\n\t\t\tconst { overflowX } = getComputedStyle( node );\r\n\r\n\t\t\tif ( /(auto|scroll)/.test( overflowX ) ) {\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif ( node.ownerDocument === node.parentNode ) {\r\n\t\treturn node;\r\n\t}\r\n\r\n\t// Continue traversing.\r\n\treturn getScrollContainer(\r\n\t\t/** @type {Element} */ ( node.parentNode ),\r\n\t\tdirection\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport getComputedStyle from './get-computed-style';\r\n\r\n/**\r\n * Returns the closest positioned element, or null under any of the conditions\r\n * of the offsetParent specification. Unlike offsetParent, this function is not\r\n * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\r\n *\r\n * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\r\n *\r\n * @param {Node} node Node from which to find offset parent.\r\n *\r\n * @return {Node | null} Offset parent.\r\n */\r\nexport default function getOffsetParent( node ) {\r\n\t// Cannot retrieve computed style or offset parent only anything other than\r\n\t// an element node, so find the closest element node.\r\n\tlet closestElement;\r\n\twhile ( ( closestElement = /** @type {Node} */ ( node.parentNode ) ) ) {\r\n\t\tif ( closestElement.nodeType === closestElement.ELEMENT_NODE ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif ( ! closestElement ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// If the closest element is already positioned, return it, as offsetParent\r\n\t// does not otherwise consider the node itself.\r\n\tif (\r\n\t\tgetComputedStyle( /** @type {Element} */ ( closestElement ) )\r\n\t\t\t.position !== 'static'\r\n\t) {\r\n\t\treturn closestElement;\r\n\t}\r\n\r\n\t// offsetParent is undocumented/draft.\r\n\treturn /** @type {Node & { offsetParent: Node }} */ ( closestElement )\r\n\t\t.offsetParent;\r\n}\r\n","/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @param {Element} element\r\n * @return {element is HTMLInputElement | HTMLTextAreaElement} Whether the element is an input or textarea\r\n */\r\nexport default function isInputOrTextArea( element ) {\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\treturn element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\nimport isInputOrTextArea from './is-input-or-text-area';\r\n\r\n/**\r\n * Check whether the contents of the element have been entirely selected.\r\n * Returns true if there is no possibility of selection.\r\n *\r\n * @param {HTMLElement} element The element to check.\r\n *\r\n * @return {boolean} True if entirely selected, false if not.\r\n */\r\nexport default function isEntirelySelected( element ) {\r\n\tif ( isInputOrTextArea( element ) ) {\r\n\t\treturn (\r\n\t\t\telement.selectionStart === 0 &&\r\n\t\t\telement.value.length === element.selectionEnd\r\n\t\t);\r\n\t}\r\n\r\n\tif ( ! element.isContentEditable ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tconst { ownerDocument } = element;\r\n\tconst { defaultView } = ownerDocument;\r\n\tassertIsDefined( defaultView, 'defaultView' );\r\n\tconst selection = defaultView.getSelection();\r\n\tassertIsDefined( selection, 'selection' );\r\n\tconst range = selection.rangeCount ? selection.getRangeAt( 0 ) : null;\r\n\r\n\tif ( ! range ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tconst { startContainer, endContainer, startOffset, endOffset } = range;\r\n\r\n\tif (\r\n\t\tstartContainer === element &&\r\n\t\tendContainer === element &&\r\n\t\tstartOffset === 0 &&\r\n\t\tendOffset === element.childNodes.length\r\n\t) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tconst lastChild = element.lastChild;\r\n\tassertIsDefined( lastChild, 'lastChild' );\r\n\tconst endContainerContentLength =\r\n\t\tendContainer.nodeType === endContainer.TEXT_NODE\r\n\t\t\t? /** @type {Text} */ ( endContainer ).data.length\r\n\t\t\t: endContainer.childNodes.length;\r\n\r\n\treturn (\r\n\t\tisDeepChild( startContainer, element, 'firstChild' ) &&\r\n\t\tisDeepChild( endContainer, element, 'lastChild' ) &&\r\n\t\tstartOffset === 0 &&\r\n\t\tendOffset === endContainerContentLength\r\n\t);\r\n}\r\n\r\n/**\r\n * Check whether the contents of the element have been entirely selected.\r\n * Returns true if there is no possibility of selection.\r\n *\r\n * @param {HTMLElement|Node}         query     The element to check.\r\n * @param {HTMLElement}              container The container that we suspect \"query\" may be a first or last child of.\r\n * @param {\"firstChild\"|\"lastChild\"} propName  \"firstChild\" or \"lastChild\"\r\n *\r\n * @return {boolean} True if query is a deep first/last child of container, false otherwise.\r\n */\r\nfunction isDeepChild( query, container, propName ) {\r\n\t/** @type {HTMLElement | ChildNode | null} */\r\n\tlet candidate = container;\r\n\tdo {\r\n\t\tif ( query === candidate ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcandidate = candidate[ propName ];\r\n\t} while ( candidate );\r\n\treturn false;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isInputOrTextArea from './is-input-or-text-area';\r\n\r\n/**\r\n *\r\n * Detects if element is a form element.\r\n *\r\n * @param {Element} element The element to check.\r\n *\r\n * @return {boolean} True if form element and false otherwise.\r\n */\r\nexport default function isFormElement( element ) {\r\n\tif ( ! element ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tconst { tagName } = element;\r\n\tconst checkForInputTextarea = isInputOrTextArea( element );\r\n\treturn (\r\n\t\tcheckForInputTextarea || tagName === 'BUTTON' || tagName === 'SELECT'\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport getComputedStyle from './get-computed-style';\r\n\r\n/**\r\n * Whether the element's text direction is right-to-left.\r\n *\r\n * @param {Element} element The element to check.\r\n *\r\n * @return {boolean} True if rtl, false if ltr.\r\n */\r\nexport default function isRTL( element ) {\r\n\treturn getComputedStyle( element ).direction === 'rtl';\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport caretRangeFromPoint from './caret-range-from-point';\r\nimport getComputedStyle from './get-computed-style';\r\n\r\n/**\r\n * Get a collapsed range for a given point.\r\n * Gives the container a temporary high z-index (above any UI).\r\n * This is preferred over getting the UI nodes and set styles there.\r\n *\r\n * @param {Document}    doc       The document of the range.\r\n * @param {number}      x         Horizontal position within the current viewport.\r\n * @param {number}      y         Vertical position within the current viewport.\r\n * @param {HTMLElement} container Container in which the range is expected to be found.\r\n *\r\n * @return {?Range} The best range for the given point.\r\n */\r\nexport default function hiddenCaretRangeFromPoint( doc, x, y, container ) {\r\n\tconst originalZIndex = container.style.zIndex;\r\n\tconst originalPosition = container.style.position;\r\n\r\n\tconst { position = 'static' } = getComputedStyle( container );\r\n\r\n\t// A z-index only works if the element position is not static.\r\n\tif ( position === 'static' ) {\r\n\t\tcontainer.style.position = 'relative';\r\n\t}\r\n\r\n\tcontainer.style.zIndex = '10000';\r\n\r\n\tconst range = caretRangeFromPoint( doc, x, y );\r\n\r\n\tcontainer.style.zIndex = originalZIndex;\r\n\tcontainer.style.position = originalPosition;\r\n\r\n\treturn range;\r\n}\r\n","/**\r\n * Polyfill.\r\n * Get a collapsed range for a given point.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\r\n *\r\n * @param {DocumentMaybeWithCaretPositionFromPoint} doc The document of the range.\r\n * @param {number}                                  x   Horizontal position within the current viewport.\r\n * @param {number}                                  y   Vertical position within the current viewport.\r\n *\r\n * @return {Range | null} The best range for the given point.\r\n */\r\nexport default function caretRangeFromPoint( doc, x, y ) {\r\n\tif ( doc.caretRangeFromPoint ) {\r\n\t\treturn doc.caretRangeFromPoint( x, y );\r\n\t}\r\n\r\n\tif ( ! doc.caretPositionFromPoint ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst point = doc.caretPositionFromPoint( x, y );\r\n\r\n\t// If x or y are negative, outside viewport, or there is no text entry node.\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\r\n\tif ( ! point ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst range = doc.createRange();\r\n\r\n\trange.setStart( point.offsetNode, point.offset );\r\n\trange.collapse( true );\r\n\r\n\treturn range;\r\n}\r\n\r\n/**\r\n * @typedef {{caretPositionFromPoint?: (x: number, y: number)=> CaretPosition | null} & Document } DocumentMaybeWithCaretPositionFromPoint\r\n * @typedef {{ readonly offset: number; readonly offsetNode: Node; getClientRect(): DOMRect | null; }} CaretPosition\r\n */\r\n","/**\r\n * If no range range can be created or it is outside the container, the element\r\n * may be out of view, so scroll it into view and try again.\r\n *\r\n * @param {HTMLElement} container  The container to scroll.\r\n * @param {boolean}     alignToTop True to align to top, false to bottom.\r\n * @param {Function}    callback   The callback to create the range.\r\n *\r\n * @return {?Range} The range returned by the callback.\r\n */\r\nexport function scrollIfNoRange( container, alignToTop, callback ) {\r\n\tlet range = callback();\r\n\r\n\t// If no range range can be created or it is outside the container, the\r\n\t// element may be out of view.\r\n\tif (\r\n\t\t! range ||\r\n\t\t! range.startContainer ||\r\n\t\t! container.contains( range.startContainer )\r\n\t) {\r\n\t\tcontainer.scrollIntoView( alignToTop );\r\n\t\trange = callback();\r\n\r\n\t\tif (\r\n\t\t\t! range ||\r\n\t\t\t! range.startContainer ||\r\n\t\t\t! container.contains( range.startContainer )\r\n\t\t) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\treturn range;\r\n}\r\n","/**\n * Internal dependencies\n */\nimport isRTL from './is-rtl';\nimport getRangeHeight from './get-range-height';\nimport getRectangleFromRange from './get-rectangle-from-range';\nimport isSelectionForward from './is-selection-forward';\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\nimport { assertIsDefined } from '../utils/assert-is-defined';\nimport isInputOrTextArea from './is-input-or-text-area';\nimport { scrollIfNoRange } from './scroll-if-no-range';\n\n/**\n * Check whether the selection is at the edge of the container. Checks for\n * horizontal position by default. Set `onlyVertical` to true to check only\n * vertically.\n *\n * @param {HTMLElement} container            Focusable element.\n * @param {boolean}     isReverse            Set to true to check left, false to check right.\n * @param {boolean}     [onlyVertical=false] Set to true to check only vertical position.\n *\n * @return {boolean} True if at the edge, false if not.\n */\nexport default function isEdge( container, isReverse, onlyVertical = false ) {\n\tif (\n\t\tisInputOrTextArea( container ) &&\n\t\ttypeof container.selectionStart === 'number'\n\t) {\n\t\tif ( container.selectionStart !== container.selectionEnd ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( isReverse ) {\n\t\t\treturn container.selectionStart === 0;\n\t\t}\n\n\t\treturn container.value.length === container.selectionStart;\n\t}\n\n\tif ( ! container.isContentEditable ) {\n\t\treturn true;\n\t}\n\n\tconst { ownerDocument } = container;\n\tconst { defaultView } = ownerDocument;\n\n\tassertIsDefined( defaultView, 'defaultView' );\n\tconst selection = defaultView.getSelection();\n\n\tif ( ! selection || ! selection.rangeCount ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getRangeAt( 0 );\n\tconst collapsedRange = range.cloneRange();\n\tconst isForward = isSelectionForward( selection );\n\tconst isCollapsed = selection.isCollapsed;\n\n\t// Collapse in direction of selection.\n\tif ( ! isCollapsed ) {\n\t\tcollapsedRange.collapse( ! isForward );\n\t}\n\n\tconst collapsedRangeRect = getRectangleFromRange( collapsedRange );\n\tconst rangeRect = getRectangleFromRange( range );\n\n\tif ( ! collapsedRangeRect || ! rangeRect ) {\n\t\treturn false;\n\t}\n\n\t// Only consider the multiline selection at the edge if the direction is\n\t// towards the edge. The selection is multiline if it is taller than the\n\t// collapsed  selection.\n\tconst rangeHeight = getRangeHeight( range );\n\tif (\n\t\t! isCollapsed &&\n\t\trangeHeight &&\n\t\trangeHeight > collapsedRangeRect.height &&\n\t\tisForward === isReverse\n\t) {\n\t\treturn false;\n\t}\n\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\n\tconst containerRect = container.getBoundingClientRect();\n\n\t// To check if a selection is at the edge, we insert a test selection at the\n\t// edge of the container and check if the selections have the same vertical\n\t// or horizontal position. If they do, the selection is at the edge.\n\t// This method proves to be better than a DOM-based calculation for the\n\t// horizontal edge, since it ignores empty textnodes and a trailing line\n\t// break element. In other words, we need to check visual positioning, not\n\t// DOM positioning.\n\t// It also proves better than using the computed style for the vertical\n\t// edge, because we cannot know the padding and line height reliably in\n\t// pixels. `getComputedStyle` may return a value with different units.\n\tconst x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\n\tconst y = isReverse ? containerRect.top + 1 : containerRect.bottom - 1;\n\tconst testRange = scrollIfNoRange( container, isReverse, () =>\n\t\thiddenCaretRangeFromPoint( ownerDocument, x, y, container )\n\t);\n\n\tif ( ! testRange ) {\n\t\treturn false;\n\t}\n\n\tconst testRect = getRectangleFromRange( testRange );\n\n\tif ( ! testRect ) {\n\t\treturn false;\n\t}\n\n\tconst verticalSide = isReverse ? 'top' : 'bottom';\n\tconst horizontalSide = isReverseDir ? 'left' : 'right';\n\tconst verticalDiff = testRect[ verticalSide ] - rangeRect[ verticalSide ];\n\tconst horizontalDiff =\n\t\ttestRect[ horizontalSide ] - collapsedRangeRect[ horizontalSide ];\n\n\t// Allow the position to be 1px off.\n\tconst hasVerticalDiff = Math.abs( verticalDiff ) <= 1;\n\tconst hasHorizontalDiff = Math.abs( horizontalDiff ) <= 1;\n\n\treturn onlyVertical\n\t\t? hasVerticalDiff\n\t\t: hasVerticalDiff && hasHorizontalDiff;\n}\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Returns true if the given selection object is in the forward direction, or\r\n * false otherwise.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\r\n *\r\n * @param {Selection} selection Selection object to check.\r\n *\r\n * @return {boolean} Whether the selection is forward.\r\n */\r\nexport default function isSelectionForward( selection ) {\r\n\tconst { anchorNode, focusNode, anchorOffset, focusOffset } = selection;\r\n\r\n\tassertIsDefined( anchorNode, 'anchorNode' );\r\n\tassertIsDefined( focusNode, 'focusNode' );\r\n\tconst position = anchorNode.compareDocumentPosition( focusNode );\r\n\r\n\t// Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\r\n\t// so bitwise operators are intended.\r\n\t/* eslint-disable no-bitwise */\r\n\t// Compare whether anchor node precedes focus node. If focus node (where\r\n\t// end of selection occurs) is after the anchor node, it is forward.\r\n\tif ( position & anchorNode.DOCUMENT_POSITION_PRECEDING ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( position & anchorNode.DOCUMENT_POSITION_FOLLOWING ) {\r\n\t\treturn true;\r\n\t}\r\n\t/* eslint-enable no-bitwise */\r\n\r\n\t// `compareDocumentPosition` returns 0 when passed the same node, in which\r\n\t// case compare offsets.\r\n\tif ( position === 0 ) {\r\n\t\treturn anchorOffset <= focusOffset;\r\n\t}\r\n\r\n\t// This should never be reached, but return true as default case.\r\n\treturn true;\r\n}\r\n","/**\r\n * Gets the height of the range without ignoring zero width rectangles, which\r\n * some browsers ignore when creating a union.\r\n *\r\n * @param {Range} range The range to check.\r\n * @return {number | undefined} Height of the range or undefined if the range has no client rectangles.\r\n */\r\nexport default function getRangeHeight( range ) {\r\n\tconst rects = Array.from( range.getClientRects() );\r\n\r\n\tif ( ! rects.length ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst highestTop = Math.min( ...rects.map( ( { top } ) => top ) );\r\n\tconst lowestBottom = Math.max( ...rects.map( ( { bottom } ) => bottom ) );\r\n\r\n\treturn lowestBottom - highestTop;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isEdge from './is-edge';\r\n\r\n/**\r\n * Check whether the selection is horizontally at the edge of the container.\r\n *\r\n * @param {HTMLElement} container Focusable element.\r\n * @param {boolean}     isReverse Set to true to check left, false for right.\r\n *\r\n * @return {boolean} True if at the horizontal edge, false if not.\r\n */\r\nexport default function isHorizontalEdge( container, isReverse ) {\r\n\treturn isEdge( container, isReverse );\r\n}\r\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"wp\"][\"deprecated\"];","/**\r\n * WordPress dependencies\r\n */\r\nimport deprecated from '@wordpress/deprecated';\r\n\r\n/**\r\n * Internal dependencies\r\n */\r\nimport isHTMLInputElement from './is-html-input-element';\r\n\r\n/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * Check whether the given element is an input field of type number.\r\n *\r\n * @param {Node} node The HTML node.\r\n *\r\n * @return {node is HTMLInputElement} True if the node is number input.\r\n */\r\nexport default function isNumberInput( node ) {\r\n\tdeprecated( 'wp.dom.isNumberInput', {\r\n\t\tsince: '6.1',\r\n\t\tversion: '6.5',\r\n\t} );\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\treturn (\r\n\t\tisHTMLInputElement( node ) &&\r\n\t\tnode.type === 'number' &&\r\n\t\t! isNaN( node.valueAsNumber )\r\n\t);\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isEdge from './is-edge';\r\n\r\n/**\r\n * Check whether the selection is vertically at the edge of the container.\r\n *\r\n * @param {HTMLElement} container Focusable element.\r\n * @param {boolean}     isReverse Set to true to check top, false for bottom.\r\n *\r\n * @return {boolean} True if at the vertical edge, false if not.\r\n */\r\nexport default function isVerticalEdge( container, isReverse ) {\r\n\treturn isEdge( container, isReverse, true );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport hiddenCaretRangeFromPoint from './hidden-caret-range-from-point';\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\nimport isInputOrTextArea from './is-input-or-text-area';\r\nimport isRTL from './is-rtl';\r\nimport { scrollIfNoRange } from './scroll-if-no-range';\r\n\r\n/**\r\n * Gets the range to place.\r\n *\r\n * @param {HTMLElement}      container Focusable element.\r\n * @param {boolean}          isReverse True for end, false for start.\r\n * @param {number|undefined} x         X coordinate to vertically position.\r\n *\r\n * @return {Range|null} The range to place.\r\n */\r\nfunction getRange( container, isReverse, x ) {\r\n\tconst { ownerDocument } = container;\r\n\t// In the case of RTL scripts, the horizontal edge is at the opposite side.\r\n\tconst isReverseDir = isRTL( container ) ? ! isReverse : isReverse;\r\n\tconst containerRect = container.getBoundingClientRect();\r\n\t// When placing at the end (isReverse), find the closest range to the bottom\r\n\t// right corner. When placing at the start, to the top left corner.\r\n\t// Ensure x is defined and within the container's boundaries. When it's\r\n\t// exactly at the boundary, it's not considered within the boundaries.\r\n\tif ( x === undefined ) {\r\n\t\tx = isReverse ? containerRect.right - 1 : containerRect.left + 1;\r\n\t} else if ( x <= containerRect.left ) {\r\n\t\tx = containerRect.left + 1;\r\n\t} else if ( x >= containerRect.right ) {\r\n\t\tx = containerRect.right - 1;\r\n\t}\r\n\tconst y = isReverseDir ? containerRect.bottom - 1 : containerRect.top + 1;\r\n\treturn hiddenCaretRangeFromPoint( ownerDocument, x, y, container );\r\n}\r\n\r\n/**\r\n * Places the caret at start or end of a given element.\r\n *\r\n * @param {HTMLElement}      container Focusable element.\r\n * @param {boolean}          isReverse True for end, false for start.\r\n * @param {number|undefined} x         X coordinate to vertically position.\r\n */\r\nexport default function placeCaretAtEdge( container, isReverse, x ) {\r\n\tif ( ! container ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tcontainer.focus();\r\n\r\n\tif ( isInputOrTextArea( container ) ) {\r\n\t\t// The element may not support selection setting.\r\n\t\tif ( typeof container.selectionStart !== 'number' ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif ( isReverse ) {\r\n\t\t\tcontainer.selectionStart = container.value.length;\r\n\t\t\tcontainer.selectionEnd = container.value.length;\r\n\t\t} else {\r\n\t\t\tcontainer.selectionStart = 0;\r\n\t\t\tcontainer.selectionEnd = 0;\r\n\t\t}\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ( ! container.isContentEditable ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst range = scrollIfNoRange( container, isReverse, () =>\r\n\t\tgetRange( container, isReverse, x )\r\n\t);\r\n\r\n\tif ( ! range ) return;\r\n\r\n\tconst { ownerDocument } = container;\r\n\tconst { defaultView } = ownerDocument;\r\n\tassertIsDefined( defaultView, 'defaultView' );\r\n\tconst selection = defaultView.getSelection();\r\n\tassertIsDefined( selection, 'selection' );\r\n\tselection.removeAllRanges();\r\n\tselection.addRange( range );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport placeCaretAtEdge from './place-caret-at-edge';\r\n\r\n/**\r\n * Places the caret at start or end of a given element.\r\n *\r\n * @param {HTMLElement} container Focusable element.\r\n * @param {boolean}     isReverse True for end, false for start.\r\n */\r\nexport default function placeCaretAtHorizontalEdge( container, isReverse ) {\r\n\treturn placeCaretAtEdge( container, isReverse, undefined );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport placeCaretAtEdge from './place-caret-at-edge';\r\n\r\n/**\r\n * Places the caret at the top or bottom of a given element.\r\n *\r\n * @param {HTMLElement} container Focusable element.\r\n * @param {boolean}     isReverse True for bottom, false for top.\r\n * @param {DOMRect}     [rect]    The rectangle to position the caret with.\r\n */\r\nexport default function placeCaretAtVerticalEdge( container, isReverse, rect ) {\r\n\treturn placeCaretAtEdge( container, isReverse, rect?.left );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Given two DOM nodes, inserts the former in the DOM as the next sibling of\r\n * the latter.\r\n *\r\n * @param {Node} newNode       Node to be inserted.\r\n * @param {Node} referenceNode Node after which to perform the insertion.\r\n * @return {void}\r\n */\r\nexport default function insertAfter( newNode, referenceNode ) {\r\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\r\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode.nextSibling );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Given a DOM node, removes it from the DOM.\r\n *\r\n * @param {Node} node Node to be removed.\r\n * @return {void}\r\n */\r\nexport default function remove( node ) {\r\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\r\n\tnode.parentNode.removeChild( node );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\nimport insertAfter from './insert-after';\r\nimport remove from './remove';\r\n\r\n/**\r\n * Given two DOM nodes, replaces the former with the latter in the DOM.\r\n *\r\n * @param {Element} processedNode Node to be removed.\r\n * @param {Element} newNode       Node to be inserted in its place.\r\n * @return {void}\r\n */\r\nexport default function replace( processedNode, newNode ) {\r\n\tassertIsDefined( processedNode.parentNode, 'processedNode.parentNode' );\r\n\tinsertAfter( newNode, processedNode.parentNode );\r\n\tremove( processedNode );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Unwrap the given node. This means any child nodes are moved to the parent.\r\n *\r\n * @param {Node} node The node to unwrap.\r\n *\r\n * @return {void}\r\n */\r\nexport default function unwrap( node ) {\r\n\tconst parent = node.parentNode;\r\n\r\n\tassertIsDefined( parent, 'node.parentNode' );\r\n\r\n\twhile ( node.firstChild ) {\r\n\t\tparent.insertBefore( node.firstChild, node );\r\n\t}\r\n\r\n\tparent.removeChild( node );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Replaces the given node with a new node with the given tag name.\r\n *\r\n * @param {Element} node    The node to replace\r\n * @param {string}  tagName The new tag name.\r\n *\r\n * @return {Element} The new node.\r\n */\r\nexport default function replaceTag( node, tagName ) {\r\n\tconst newNode = node.ownerDocument.createElement( tagName );\r\n\r\n\twhile ( node.firstChild ) {\r\n\t\tnewNode.appendChild( node.firstChild );\r\n\t}\r\n\r\n\tassertIsDefined( node.parentNode, 'node.parentNode' );\r\n\tnode.parentNode.replaceChild( newNode, node );\r\n\r\n\treturn newNode;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport { assertIsDefined } from '../utils/assert-is-defined';\r\n\r\n/**\r\n * Wraps the given node with a new node with the given tag name.\r\n *\r\n * @param {Element} newNode       The node to insert.\r\n * @param {Element} referenceNode The node to wrap.\r\n */\r\nexport default function wrap( newNode, referenceNode ) {\r\n\tassertIsDefined( referenceNode.parentNode, 'referenceNode.parentNode' );\r\n\treferenceNode.parentNode.insertBefore( newNode, referenceNode );\r\n\tnewNode.appendChild( referenceNode );\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport remove from './remove';\r\n\r\n/**\r\n * Strips scripts and on* attributes from HTML.\r\n *\r\n * @param {string} html HTML to sanitize.\r\n *\r\n * @return {string} The sanitized HTML.\r\n */\r\nexport default function safeHTML( html ) {\r\n\tconst { body } = document.implementation.createHTMLDocument( '' );\r\n\tbody.innerHTML = html;\r\n\tconst elements = body.getElementsByTagName( '*' );\r\n\tlet elementIndex = elements.length;\r\n\r\n\twhile ( elementIndex-- ) {\r\n\t\tconst element = elements[ elementIndex ];\r\n\r\n\t\tif ( element.tagName === 'SCRIPT' ) {\r\n\t\t\tremove( element );\r\n\t\t} else {\r\n\t\t\tlet attributeIndex = element.attributes.length;\r\n\r\n\t\t\twhile ( attributeIndex-- ) {\r\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\r\n\r\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\r\n\t\t\t\t\telement.removeAttribute( key );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn body.innerHTML;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport safeHTML from './safe-html';\r\n\r\n/**\r\n * Removes any HTML tags from the provided string.\r\n *\r\n * @param {string} html The string containing html.\r\n *\r\n * @return {string} The text content with any html removed.\r\n */\r\nexport default function stripHTML( html ) {\r\n\t// Remove any script tags or on* attributes otherwise their *contents* will be left\r\n\t// in place following removal of HTML tags.\r\n\thtml = safeHTML( html );\r\n\r\n\tconst doc = document.implementation.createHTMLDocument( '' );\r\n\tdoc.body.innerHTML = html;\r\n\treturn doc.body.textContent || '';\r\n}\r\n","/**\r\n * Recursively checks if an element is empty. An element is not empty if it\r\n * contains text or contains elements with attributes such as images.\r\n *\r\n * @param {Element} element The element to check.\r\n *\r\n * @return {boolean} Whether or not the element is empty.\r\n */\r\nexport default function isEmpty( element ) {\r\n\tswitch ( element.nodeType ) {\r\n\t\tcase element.TEXT_NODE:\r\n\t\t\t// We cannot use \\s since it includes special spaces which we want\r\n\t\t\t// to preserve.\r\n\t\t\treturn /^[ \\f\\n\\r\\t\\v\\u00a0]*$/.test( element.nodeValue || '' );\r\n\t\tcase element.ELEMENT_NODE:\r\n\t\t\tif ( element.hasAttributes() ) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if ( ! element.hasChildNodes() ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn /** @type {Element[]} */ (\r\n\t\t\t\tArray.from( element.childNodes )\r\n\t\t\t).every( isEmpty );\r\n\t\tdefault:\r\n\t\t\treturn true;\r\n\t}\r\n}\r\n","/**\r\n * All phrasing content elements.\r\n *\r\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\r\n */\r\n\r\n/**\r\n * @typedef {Record<string,SemanticElementDefinition>} ContentSchema\r\n */\r\n\r\n/**\r\n * @typedef SemanticElementDefinition\r\n * @property {string[]}      [attributes] Content attributes\r\n * @property {ContentSchema} [children]   Content attributes\r\n */\r\n\r\n/**\r\n * All text-level semantic elements.\r\n *\r\n * @see https://html.spec.whatwg.org/multipage/text-level-semantics.html\r\n *\r\n * @type {ContentSchema}\r\n */\r\nconst textContentSchema = {\r\n\tstrong: {},\r\n\tem: {},\r\n\ts: {},\r\n\tdel: {},\r\n\tins: {},\r\n\ta: { attributes: [ 'href', 'target', 'rel', 'id' ] },\r\n\tcode: {},\r\n\tabbr: { attributes: [ 'title' ] },\r\n\tsub: {},\r\n\tsup: {},\r\n\tbr: {},\r\n\tsmall: {},\r\n\t// To do: fix blockquote.\r\n\t// cite: {},\r\n\tq: { attributes: [ 'cite' ] },\r\n\tdfn: { attributes: [ 'title' ] },\r\n\tdata: { attributes: [ 'value' ] },\r\n\ttime: { attributes: [ 'datetime' ] },\r\n\tvar: {},\r\n\tsamp: {},\r\n\tkbd: {},\r\n\ti: {},\r\n\tb: {},\r\n\tu: {},\r\n\tmark: {},\r\n\truby: {},\r\n\trt: {},\r\n\trp: {},\r\n\tbdi: { attributes: [ 'dir' ] },\r\n\tbdo: { attributes: [ 'dir' ] },\r\n\twbr: {},\r\n\t'#text': {},\r\n};\r\n\r\n// Recursion is needed.\r\n// Possible: strong > em > strong.\r\n// Impossible: strong > strong.\r\nconst excludedElements = [ '#text', 'br' ];\r\nObject.keys( textContentSchema )\r\n\t.filter( ( element ) => ! excludedElements.includes( element ) )\r\n\t.forEach( ( tag ) => {\r\n\t\tconst { [ tag ]: removedTag, ...restSchema } = textContentSchema;\r\n\t\ttextContentSchema[ tag ].children = restSchema;\r\n\t} );\r\n\r\n/**\r\n * Embedded content elements.\r\n *\r\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#embedded-content-0\r\n *\r\n * @type {ContentSchema}\r\n */\r\nconst embeddedContentSchema = {\r\n\taudio: {\r\n\t\tattributes: [\r\n\t\t\t'src',\r\n\t\t\t'preload',\r\n\t\t\t'autoplay',\r\n\t\t\t'mediagroup',\r\n\t\t\t'loop',\r\n\t\t\t'muted',\r\n\t\t],\r\n\t},\r\n\tcanvas: { attributes: [ 'width', 'height' ] },\r\n\tembed: { attributes: [ 'src', 'type', 'width', 'height' ] },\r\n\timg: {\r\n\t\tattributes: [\r\n\t\t\t'alt',\r\n\t\t\t'src',\r\n\t\t\t'srcset',\r\n\t\t\t'usemap',\r\n\t\t\t'ismap',\r\n\t\t\t'width',\r\n\t\t\t'height',\r\n\t\t],\r\n\t},\r\n\tobject: {\r\n\t\tattributes: [\r\n\t\t\t'data',\r\n\t\t\t'type',\r\n\t\t\t'name',\r\n\t\t\t'usemap',\r\n\t\t\t'form',\r\n\t\t\t'width',\r\n\t\t\t'height',\r\n\t\t],\r\n\t},\r\n\tvideo: {\r\n\t\tattributes: [\r\n\t\t\t'src',\r\n\t\t\t'poster',\r\n\t\t\t'preload',\r\n\t\t\t'playsinline',\r\n\t\t\t'autoplay',\r\n\t\t\t'mediagroup',\r\n\t\t\t'loop',\r\n\t\t\t'muted',\r\n\t\t\t'controls',\r\n\t\t\t'width',\r\n\t\t\t'height',\r\n\t\t],\r\n\t},\r\n};\r\n\r\n/**\r\n * Phrasing content elements.\r\n *\r\n * @see https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html#phrasing-content-0\r\n */\r\nconst phrasingContentSchema = {\r\n\t...textContentSchema,\r\n\t...embeddedContentSchema,\r\n};\r\n\r\n/**\r\n * Get schema of possible paths for phrasing content.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\r\n *\r\n * @param {string} [context] Set to \"paste\" to exclude invisible elements and\r\n *                           sensitive data.\r\n *\r\n * @return {Partial<ContentSchema>} Schema.\r\n */\r\nexport function getPhrasingContentSchema( context ) {\r\n\tif ( context !== 'paste' ) {\r\n\t\treturn phrasingContentSchema;\r\n\t}\r\n\r\n\t/**\r\n\t * @type {Partial<ContentSchema>}\r\n\t */\r\n\tconst {\r\n\t\tu, // Used to mark misspelling. Shouldn't be pasted.\r\n\t\tabbr, // Invisible.\r\n\t\tdata, // Invisible.\r\n\t\ttime, // Invisible.\r\n\t\twbr, // Invisible.\r\n\t\tbdi, // Invisible.\r\n\t\tbdo, // Invisible.\r\n\t\t...remainingContentSchema\r\n\t} = {\r\n\t\t...phrasingContentSchema,\r\n\t\t// We shouldn't paste potentially sensitive information which is not\r\n\t\t// visible to the user when pasted, so strip the attributes.\r\n\t\tins: { children: phrasingContentSchema.ins.children },\r\n\t\tdel: { children: phrasingContentSchema.del.children },\r\n\t};\r\n\r\n\treturn remainingContentSchema;\r\n}\r\n\r\n/**\r\n * Find out whether or not the given node is phrasing content.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\r\n *\r\n * @param {Node} node The node to test.\r\n *\r\n * @return {boolean} True if phrasing content, false if not.\r\n */\r\nexport function isPhrasingContent( node ) {\r\n\tconst tag = node.nodeName.toLowerCase();\r\n\treturn getPhrasingContentSchema().hasOwnProperty( tag ) || tag === 'span';\r\n}\r\n\r\n/**\r\n * @param {Node} node\r\n * @return {boolean} Node is text content\r\n */\r\nexport function isTextContent( node ) {\r\n\tconst tag = node.nodeName.toLowerCase();\r\n\treturn textContentSchema.hasOwnProperty( tag ) || tag === 'span';\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport isEmpty from './is-empty';\r\nimport remove from './remove';\r\nimport unwrap from './unwrap';\r\nimport { isPhrasingContent } from '../phrasing-content';\r\nimport insertAfter from './insert-after';\r\nimport isElement from './is-element';\r\n\r\nconst noop = () => {};\r\n\r\n/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @typedef SchemaItem\r\n * @property {string[]}                            [attributes] Attributes.\r\n * @property {(string | RegExp)[]}                 [classes]    Classnames or RegExp to test against.\r\n * @property {'*' | { [tag: string]: SchemaItem }} [children]   Child schemas.\r\n * @property {string[]}                            [require]    Selectors to test required children against. Leave empty or undefined if there are no requirements.\r\n * @property {boolean}                             allowEmpty   Whether to allow nodes without children.\r\n * @property {(node: Node) => boolean}             [isMatch]    Function to test whether a node is a match. If left undefined any node will be assumed to match.\r\n */\r\n\r\n/** @typedef {{ [tag: string]: SchemaItem }} Schema */\r\n/* eslint-enable jsdoc/valid-types */\r\n\r\n/**\r\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\r\n * list.\r\n *\r\n * @param {NodeList} nodeList The nodeList to filter.\r\n * @param {Document} doc      The document of the nodeList.\r\n * @param {Schema}   schema   An array of functions that can mutate with the provided node.\r\n * @param {boolean}  inline   Whether to clean for inline mode.\r\n */\r\nexport default function cleanNodeList( nodeList, doc, schema, inline ) {\r\n\tArray.from( nodeList ).forEach(\r\n\t\t( /** @type {Node & { nextElementSibling?: unknown }} */ node ) => {\r\n\t\t\tconst tag = node.nodeName.toLowerCase();\r\n\r\n\t\t\t// It's a valid child, if the tag exists in the schema without an isMatch\r\n\t\t\t// function, or with an isMatch function that matches the node.\r\n\t\t\tif (\r\n\t\t\t\tschema.hasOwnProperty( tag ) &&\r\n\t\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch?.( node ) )\r\n\t\t\t) {\r\n\t\t\t\tif ( isElement( node ) ) {\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tattributes = [],\r\n\t\t\t\t\t\tclasses = [],\r\n\t\t\t\t\t\tchildren,\r\n\t\t\t\t\t\trequire = [],\r\n\t\t\t\t\t\tallowEmpty,\r\n\t\t\t\t\t} = schema[ tag ];\r\n\r\n\t\t\t\t\t// If the node is empty and it's supposed to have children,\r\n\t\t\t\t\t// remove the node.\r\n\t\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\r\n\t\t\t\t\t\tremove( node );\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( node.hasAttributes() ) {\r\n\t\t\t\t\t\t// Strip invalid attributes.\r\n\t\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tname !== 'class' &&\r\n\t\t\t\t\t\t\t\t! attributes.includes( name )\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tnode.removeAttribute( name );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t// Strip invalid classes.\r\n\t\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\r\n\t\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\r\n\t\t\t\t\t\tif ( node.classList && node.classList.length ) {\r\n\t\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\r\n\t\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\r\n\t\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\r\n\t\t\t\t\t\t\t\t\t) => className === item;\r\n\t\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\r\n\t\t\t\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\t\t\t\t/** @type {string} */ className\r\n\t\t\t\t\t\t\t\t\t) => item.test( className );\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\treturn noop;\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\r\n\t\t\t\t\t\t\t\t\t\tisMatch( name )\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tnode.classList.remove( name );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\tif ( ! node.classList.length ) {\r\n\t\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( node.hasChildNodes() ) {\r\n\t\t\t\t\t\t// Do not filter any content.\r\n\t\t\t\t\t\tif ( children === '*' ) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Continue if the node is supposed to have children.\r\n\t\t\t\t\t\tif ( children ) {\r\n\t\t\t\t\t\t\t// If a parent requires certain children, but it does\r\n\t\t\t\t\t\t\t// not have them, drop the parent and continue.\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\trequire.length &&\r\n\t\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tcleanNodeList(\r\n\t\t\t\t\t\t\t\t\tnode.childNodes,\r\n\t\t\t\t\t\t\t\t\tdoc,\r\n\t\t\t\t\t\t\t\t\tschema,\r\n\t\t\t\t\t\t\t\t\tinline\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\tunwrap( node );\r\n\t\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\r\n\t\t\t\t\t\t\t\t// contains children that are block content, unwrap\r\n\t\t\t\t\t\t\t\t// the node because it is invalid.\r\n\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\tnode.parentNode &&\r\n\t\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\r\n\t\t\t\t\t\t\t\tisPhrasingContent( node )\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tcleanNodeList(\r\n\t\t\t\t\t\t\t\t\tnode.childNodes,\r\n\t\t\t\t\t\t\t\t\tdoc,\r\n\t\t\t\t\t\t\t\t\tschema,\r\n\t\t\t\t\t\t\t\t\tinline\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\r\n\t\t\t\t\t\t\t\t\t\t( child ) =>\r\n\t\t\t\t\t\t\t\t\t\t\t! isPhrasingContent( child )\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tunwrap( node );\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcleanNodeList(\r\n\t\t\t\t\t\t\t\t\tnode.childNodes,\r\n\t\t\t\t\t\t\t\t\tdoc,\r\n\t\t\t\t\t\t\t\t\tchildren,\r\n\t\t\t\t\t\t\t\t\tinline\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\twhile ( node.firstChild ) {\r\n\t\t\t\t\t\t\t\tremove( node.firstChild );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\r\n\t\t\t} else {\r\n\t\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\r\n\r\n\t\t\t\t// For inline mode, insert a line break when unwrapping nodes that\r\n\t\t\t\t// are not phrasing content.\r\n\t\t\t\tif (\r\n\t\t\t\t\tinline &&\r\n\t\t\t\t\t! isPhrasingContent( node ) &&\r\n\t\t\t\t\tnode.nextElementSibling\r\n\t\t\t\t) {\r\n\t\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tunwrap( node );\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n","/* eslint-disable jsdoc/valid-types */\r\n/**\r\n * @param {Node | null | undefined} node\r\n * @return {node is Element} True if node is an Element node\r\n */\r\nexport default function isElement( node ) {\r\n\t/* eslint-enable jsdoc/valid-types */\r\n\treturn !! node && node.nodeType === node.ELEMENT_NODE;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport cleanNodeList from './clean-node-list';\r\n\r\n/**\r\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\r\n *\r\n * @param {string}                             HTML   The HTML to clean up.\r\n * @param {import('./clean-node-list').Schema} schema Schema for the HTML.\r\n * @param {boolean}                            inline Whether to clean for inline mode.\r\n *\r\n * @return {string} The cleaned up HTML.\r\n */\r\nexport default function removeInvalidHTML( HTML, schema, inline ) {\r\n\tconst doc = document.implementation.createHTMLDocument( '' );\r\n\r\n\tdoc.body.innerHTML = HTML;\r\n\r\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\r\n\r\n\treturn doc.body.innerHTML;\r\n}\r\n","/**\r\n * Gets all files from a DataTransfer object.\r\n *\r\n * @param {DataTransfer} dataTransfer DataTransfer object to inspect.\r\n *\r\n * @return {File[]} An array containing all files.\r\n */\r\nexport function getFilesFromDataTransfer( dataTransfer ) {\r\n\tconst files = Array.from( dataTransfer.files );\r\n\r\n\tArray.from( dataTransfer.items ).forEach( ( item ) => {\r\n\t\tconst file = item.getAsFile();\r\n\r\n\t\tif (\r\n\t\t\tfile &&\r\n\t\t\t! files.find(\r\n\t\t\t\t( { name, type, size } ) =>\r\n\t\t\t\t\tname === file.name &&\r\n\t\t\t\t\ttype === file.type &&\r\n\t\t\t\t\tsize === file.size\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tfiles.push( file );\r\n\t\t}\r\n\t} );\r\n\r\n\treturn files;\r\n}\r\n","/**\r\n * Internal dependencies\r\n */\r\nimport * as focusable from './focusable';\r\nimport * as tabbable from './tabbable';\r\n\r\n/**\r\n * Object grouping `focusable` and `tabbable` utils\r\n * under the keys with the same name.\r\n */\r\nexport const focus = { focusable, tabbable };\r\n\r\nexport * from './dom';\r\nexport * from './phrasing-content';\r\nexport * from './data-transfer';\r\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","isVisible","element","offsetWidth","offsetHeight","getClientRects","length","find","context","sequential","elements","querySelectorAll","join","buildSelector","Array","from","filter","nodeName","map","closest","img","ownerDocument","querySelector","name","isValidFocusableArea","getTabIndex","tabIndex","getAttribute","parseInt","isTabbableIndex","mapElementToObjectTabbable","index","mapObjectTabbableToElement","object","compareObjectTabbables","b","aTabIndex","bTabIndex","filterTabbable","focusables","sort","reduce","CHOSEN_RADIO_BY_NAME","result","type","checked","concat","hasChosen","hadChosenElement","e","createStatefulCollapseRadioGroup","findFocusable","findPrevious","body","reverse","focusable","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","findNext","DOCUMENT_POSITION_FOLLOWING","getRectangleFromRange","range","collapsed","rects","filteredRects","width","getBoundingClientRect","top","furthestTop","bottom","furthestBottom","left","furthestLeft","right","furthestRight","window","DOMRect","startContainer","parentNode","childNodes","indexOf","createRange","setStart","setEnd","rect","height","padNode","createTextNode","cloneRange","insertNode","removeChild","computeCaretRect","win","selection","getSelection","rangeCount","getRangeAt","documentHasTextSelection","doc","defaultView","isHTMLInputElement","node","isTextField","includes","contentEditable","documentHasUncollapsedSelection","activeElement","selectionStart","selectionEnd","error","inputFieldHasUncollapsedSelection","documentHasSelection","getComputedStyle","getScrollContainer","direction","scrollHeight","clientHeight","overflowY","test","scrollWidth","clientWidth","overflowX","getOffsetParent","closestElement","nodeType","ELEMENT_NODE","position","offsetParent","isInputOrTextArea","tagName","isEntirelySelected","isContentEditable","endContainer","startOffset","endOffset","lastChild","endContainerContentLength","TEXT_NODE","data","isDeepChild","query","container","propName","candidate","isFormElement","isRTL","hiddenCaretRangeFromPoint","x","y","originalZIndex","style","zIndex","originalPosition","caretRangeFromPoint","caretPositionFromPoint","point","offsetNode","offset","collapse","scrollIfNoRange","alignToTop","callback","contains","scrollIntoView","isEdge","isReverse","onlyVertical","collapsedRange","isForward","anchorNode","focusNode","anchorOffset","focusOffset","isSelectionForward","isCollapsed","collapsedRangeRect","rangeRect","rangeHeight","highestTop","Math","min","max","getRangeHeight","isReverseDir","containerRect","testRange","testRect","verticalSide","horizontalSide","verticalDiff","horizontalDiff","hasVerticalDiff","abs","hasHorizontalDiff","isHorizontalEdge","isNumberInput","deprecated","since","version","isNaN","valueAsNumber","isVerticalEdge","placeCaretAtEdge","focus","undefined","getRange","removeAllRanges","addRange","placeCaretAtHorizontalEdge","placeCaretAtVerticalEdge","insertAfter","newNode","referenceNode","insertBefore","nextSibling","remove","replace","processedNode","unwrap","parent","firstChild","replaceTag","createElement","appendChild","replaceChild","wrap","safeHTML","html","document","implementation","createHTMLDocument","innerHTML","getElementsByTagName","elementIndex","attributeIndex","attributes","startsWith","removeAttribute","stripHTML","textContent","isEmpty","nodeValue","hasAttributes","hasChildNodes","every","textContentSchema","strong","em","s","del","ins","code","abbr","sub","sup","br","small","q","dfn","time","var","samp","kbd","i","u","mark","ruby","rt","rp","bdi","bdo","wbr","excludedElements","keys","forEach","tag","removedTag","restSchema","children","phrasingContentSchema","audio","canvas","embed","video","getPhrasingContentSchema","remainingContentSchema","isPhrasingContent","toLowerCase","isTextContent","noop","cleanNodeList","nodeList","schema","inline","isMatch","nextElementSibling","isElement","classes","require","allowEmpty","classList","mattchers","item","className","RegExp","some","child","removeInvalidHTML","HTML","getFilesFromDataTransfer","dataTransfer","files","items","file","getAsFile","size","push","tabbable"],"sourceRoot":""}